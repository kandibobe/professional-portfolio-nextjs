import {
  NextjsRouterMocksNotAvailable,
  require_interop_require_default,
  require_interop_require_wildcard,
  require_segment
} from "./chunk-6L54ILII.js";
import {
  fn2
} from "./chunk-DMFXD35C.js";
import {
  require_react
} from "./chunk-NHF6FEIB.js";
import {
  __commonJS,
  __export,
  __reExport,
  __toESM
} from "./chunk-TM6AOUSD.js";

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js
var require_remove_trailing_slash = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "removeTrailingSlash", {
      enumerable: true,
      get: function() {
        return removeTrailingSlash;
      }
    });
    function removeTrailingSlash(route) {
      return route.replace(/\/$/, "") || "/";
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js
var require_get_asset_path_from_route = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/get-asset-path-from-route.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return getAssetPathFromRoute;
      }
    });
    function getAssetPathFromRoute(route, ext) {
      if (ext === void 0) ext = "";
      const path = route === "/" ? "/index" : /^\/index(\/|$)/.test(route) ? "/index" + route : route;
      return path + ext;
    }
  }
});

// portfolio-site/node_modules/next/dist/client/trusted-types.js
var require_trusted_types = __commonJS({
  "portfolio-site/node_modules/next/dist/client/trusted-types.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "__unsafeCreateTrustedScriptURL", {
      enumerable: true,
      get: function() {
        return __unsafeCreateTrustedScriptURL;
      }
    });
    var policy;
    function getPolicy() {
      if (typeof policy === "undefined" && typeof window !== "undefined") {
        var _window_trustedTypes;
        policy = ((_window_trustedTypes = window.trustedTypes) == null ? void 0 : _window_trustedTypes.createPolicy("nextjs", {
          createHTML: (input) => input,
          createScript: (input) => input,
          createScriptURL: (input) => input
        })) || null;
      }
      return policy;
    }
    function __unsafeCreateTrustedScriptURL(url) {
      var _getPolicy;
      return ((_getPolicy = getPolicy()) == null ? void 0 : _getPolicy.createScriptURL(url)) || url;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/client/request-idle-callback.js
var require_request_idle_callback = __commonJS({
  "portfolio-site/node_modules/next/dist/client/request-idle-callback.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      cancelIdleCallback: function() {
        return cancelIdleCallback;
      },
      requestIdleCallback: function() {
        return requestIdleCallback;
      }
    });
    var requestIdleCallback = typeof self !== "undefined" && self.requestIdleCallback && self.requestIdleCallback.bind(window) || function(cb) {
      let start = Date.now();
      return self.setTimeout(function() {
        cb({
          didTimeout: false,
          timeRemaining: function() {
            return Math.max(0, 50 - (Date.now() - start));
          }
        });
      }, 1);
    };
    var cancelIdleCallback = typeof self !== "undefined" && self.cancelIdleCallback && self.cancelIdleCallback.bind(window) || function(id) {
      return clearTimeout(id);
    };
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/build/deployment-id.js
var require_deployment_id = __commonJS({
  "portfolio-site/node_modules/next/dist/build/deployment-id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getDeploymentIdQueryOrEmptyString", {
      enumerable: true,
      get: function() {
        return getDeploymentIdQueryOrEmptyString;
      }
    });
    function getDeploymentIdQueryOrEmptyString() {
      if (process.env.NEXT_DEPLOYMENT_ID) {
        return `?dpl=${process.env.NEXT_DEPLOYMENT_ID}`;
      }
      return "";
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/encode-uri-path.js
var require_encode_uri_path = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/encode-uri-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "encodeURIPath", {
      enumerable: true,
      get: function() {
        return encodeURIPath;
      }
    });
    function encodeURIPath(file) {
      return file.split("/").map((p) => encodeURIComponent(p)).join("/");
    }
  }
});

// portfolio-site/node_modules/next/dist/client/route-loader.js
var require_route_loader = __commonJS({
  "portfolio-site/node_modules/next/dist/client/route-loader.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      createRouteLoader: function() {
        return createRouteLoader;
      },
      getClientBuildManifest: function() {
        return getClientBuildManifest;
      },
      isAssetError: function() {
        return isAssetError;
      },
      markAssetError: function() {
        return markAssetError;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _getassetpathfromroute = _interop_require_default._(require_get_asset_path_from_route());
    var _trustedtypes = require_trusted_types();
    var _requestidlecallback = require_request_idle_callback();
    var _deploymentid = require_deployment_id();
    var _encodeuripath = require_encode_uri_path();
    var MS_MAX_IDLE_DELAY = 3800;
    function withFuture(key, map, generator) {
      let entry = map.get(key);
      if (entry) {
        if ("future" in entry) {
          return entry.future;
        }
        return Promise.resolve(entry);
      }
      let resolver;
      const prom = new Promise((resolve) => {
        resolver = resolve;
      });
      map.set(key, {
        resolve: resolver,
        future: prom
      });
      return generator ? generator().then((value) => {
        resolver(value);
        return value;
      }).catch((err) => {
        map.delete(key);
        throw err;
      }) : prom;
    }
    var ASSET_LOAD_ERROR = /* @__PURE__ */ Symbol("ASSET_LOAD_ERROR");
    function markAssetError(err) {
      return Object.defineProperty(err, ASSET_LOAD_ERROR, {});
    }
    function isAssetError(err) {
      return err && ASSET_LOAD_ERROR in err;
    }
    function hasPrefetch(link) {
      try {
        link = document.createElement("link");
        return (
          // detect IE11 since it supports prefetch but isn't detected
          // with relList.support
          !!window.MSInputMethodContext && !!document.documentMode || link.relList.supports("prefetch")
        );
      } catch (e) {
        return false;
      }
    }
    var canPrefetch = hasPrefetch();
    var getAssetQueryString = () => {
      return (0, _deploymentid.getDeploymentIdQueryOrEmptyString)();
    };
    function prefetchViaDom(href, as, link) {
      return new Promise((resolve, reject) => {
        const selector = '\n      link[rel="prefetch"][href^="' + href + '"],\n      link[rel="preload"][href^="' + href + '"],\n      script[src^="' + href + '"]';
        if (document.querySelector(selector)) {
          return resolve();
        }
        link = document.createElement("link");
        if (as) link.as = as;
        link.rel = "prefetch";
        link.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;
        link.onload = resolve;
        link.onerror = () => reject(markAssetError(Object.defineProperty(new Error("Failed to prefetch: " + href), "__NEXT_ERROR_CODE", {
          value: "E268",
          enumerable: false,
          configurable: true
        })));
        link.href = href;
        document.head.appendChild(link);
      });
    }
    function appendScript(src, script) {
      return new Promise((resolve, reject) => {
        script = document.createElement("script");
        script.onload = resolve;
        script.onerror = () => reject(markAssetError(Object.defineProperty(new Error("Failed to load script: " + src), "__NEXT_ERROR_CODE", {
          value: "E74",
          enumerable: false,
          configurable: true
        })));
        script.crossOrigin = process.env.__NEXT_CROSS_ORIGIN;
        script.src = src;
        document.body.appendChild(script);
      });
    }
    var devBuildPromise;
    function resolvePromiseWithTimeout(p, ms, err) {
      return new Promise((resolve, reject) => {
        let cancelled = false;
        p.then((r) => {
          cancelled = true;
          resolve(r);
        }).catch(reject);
        if (true) {
          ;
          (devBuildPromise || Promise.resolve()).then(() => {
            (0, _requestidlecallback.requestIdleCallback)(() => setTimeout(() => {
              if (!cancelled) {
                reject(err);
              }
            }, ms));
          });
        }
        if (false) {
          (0, _requestidlecallback.requestIdleCallback)(() => setTimeout(() => {
            if (!cancelled) {
              reject(err);
            }
          }, ms));
        }
      });
    }
    function getClientBuildManifest() {
      if (self.__BUILD_MANIFEST) {
        return Promise.resolve(self.__BUILD_MANIFEST);
      }
      const onBuildManifest = new Promise((resolve) => {
        const cb = self.__BUILD_MANIFEST_CB;
        self.__BUILD_MANIFEST_CB = () => {
          resolve(self.__BUILD_MANIFEST);
          cb && cb();
        };
      });
      return resolvePromiseWithTimeout(onBuildManifest, MS_MAX_IDLE_DELAY, markAssetError(Object.defineProperty(new Error("Failed to load client build manifest"), "__NEXT_ERROR_CODE", {
        value: "E273",
        enumerable: false,
        configurable: true
      })));
    }
    function getFilesForRoute(assetPrefix, route) {
      if (true) {
        const scriptUrl = assetPrefix + "/_next/static/chunks/pages" + (0, _encodeuripath.encodeURIPath)((0, _getassetpathfromroute.default)(route, ".js")) + getAssetQueryString();
        return Promise.resolve({
          scripts: [
            (0, _trustedtypes.__unsafeCreateTrustedScriptURL)(scriptUrl)
          ],
          // Styles are handled by `style-loader` in development:
          css: []
        });
      }
      return getClientBuildManifest().then((manifest) => {
        if (!(route in manifest)) {
          throw markAssetError(Object.defineProperty(new Error("Failed to lookup route: " + route), "__NEXT_ERROR_CODE", {
            value: "E446",
            enumerable: false,
            configurable: true
          }));
        }
        const allFiles = manifest[route].map((entry) => assetPrefix + "/_next/" + (0, _encodeuripath.encodeURIPath)(entry));
        return {
          scripts: allFiles.filter((v) => v.endsWith(".js")).map((v) => (0, _trustedtypes.__unsafeCreateTrustedScriptURL)(v) + getAssetQueryString()),
          css: allFiles.filter((v) => v.endsWith(".css")).map((v) => v + getAssetQueryString())
        };
      });
    }
    function createRouteLoader(assetPrefix) {
      const entrypoints = /* @__PURE__ */ new Map();
      const loadedScripts = /* @__PURE__ */ new Map();
      const styleSheets = /* @__PURE__ */ new Map();
      const routes = /* @__PURE__ */ new Map();
      function maybeExecuteScript(src) {
        if (false) {
          let prom = loadedScripts.get(src.toString());
          if (prom) {
            return prom;
          }
          if (document.querySelector('script[src^="' + src + '"]')) {
            return Promise.resolve();
          }
          loadedScripts.set(src.toString(), prom = appendScript(src));
          return prom;
        } else {
          return appendScript(src);
        }
      }
      function fetchStyleSheet(href) {
        let prom = styleSheets.get(href);
        if (prom) {
          return prom;
        }
        styleSheets.set(href, prom = fetch(href, {
          credentials: "same-origin"
        }).then((res) => {
          if (!res.ok) {
            throw Object.defineProperty(new Error("Failed to load stylesheet: " + href), "__NEXT_ERROR_CODE", {
              value: "E189",
              enumerable: false,
              configurable: true
            });
          }
          return res.text().then((text) => ({
            href,
            content: text
          }));
        }).catch((err) => {
          throw markAssetError(err);
        }));
        return prom;
      }
      return {
        whenEntrypoint(route) {
          return withFuture(route, entrypoints);
        },
        onEntrypoint(route, execute) {
          ;
          (execute ? Promise.resolve().then(() => execute()).then((exports1) => ({
            component: exports1 && exports1.default || exports1,
            exports: exports1
          }), (err) => ({
            error: err
          })) : Promise.resolve(void 0)).then((input) => {
            const old = entrypoints.get(route);
            if (old && "resolve" in old) {
              if (input) {
                entrypoints.set(route, input);
                old.resolve(input);
              }
            } else {
              if (input) {
                entrypoints.set(route, input);
              } else {
                entrypoints.delete(route);
              }
              routes.delete(route);
            }
          });
        },
        loadRoute(route, prefetch) {
          return withFuture(route, routes, () => {
            let devBuildPromiseResolve;
            if (true) {
              devBuildPromise = new Promise((resolve) => {
                devBuildPromiseResolve = resolve;
              });
            }
            return resolvePromiseWithTimeout(getFilesForRoute(assetPrefix, route).then((param) => {
              let { scripts, css } = param;
              return Promise.all([
                entrypoints.has(route) ? [] : Promise.all(scripts.map(maybeExecuteScript)),
                Promise.all(css.map(fetchStyleSheet))
              ]);
            }).then((res) => {
              return this.whenEntrypoint(route).then((entrypoint) => ({
                entrypoint,
                styles: res[1]
              }));
            }), MS_MAX_IDLE_DELAY, markAssetError(Object.defineProperty(new Error("Route did not complete loading: " + route), "__NEXT_ERROR_CODE", {
              value: "E12",
              enumerable: false,
              configurable: true
            }))).then((param) => {
              let { entrypoint, styles } = param;
              const res = Object.assign({
                styles
              }, entrypoint);
              return "error" in entrypoint ? entrypoint : res;
            }).catch((err) => {
              if (prefetch) {
                throw err;
              }
              return {
                error: err
              };
            }).finally(() => devBuildPromiseResolve == null ? void 0 : devBuildPromiseResolve());
          });
        },
        prefetch(route) {
          let cn;
          if (cn = navigator.connection) {
            if (cn.saveData || /2g/.test(cn.effectiveType)) return Promise.resolve();
          }
          return getFilesForRoute(assetPrefix, route).then((output) => Promise.all(canPrefetch ? output.scripts.map((script) => prefetchViaDom(script.toString(), "script")) : [])).then(() => {
            (0, _requestidlecallback.requestIdleCallback)(() => this.loadRoute(route, true).catch(() => {
            }));
          }).catch(
            // swallow prefetch errors
            () => {
            }
          );
        }
      };
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js
var require_react_jsx_runtime_development = __commonJS({
  "portfolio-site/node_modules/next/dist/compiled/react/cjs/react-jsx-runtime.development.js"(exports) {
    "use strict";
    (function() {
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x) {
              }
          }
        return null;
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type);
          return name ? "<" + name + ">" : "<...>";
        } catch (x) {
          return "<...>";
        }
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      function hasValidKey(config) {
        if (hasOwnProperty.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement(type, key, props, owner, debugStack, debugTask) {
        var refProp = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function jsxDEVImpl(type, config, maybeKey, isStaticChildren, debugStack, debugTask) {
        var children = config.children;
        if (void 0 !== children)
          if (isStaticChildren)
            if (isArrayImpl(children)) {
              for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
                validateChildKeys(children[isStaticChildren]);
              Object.freeze && Object.freeze(children);
            } else
              console.error(
                "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
              );
          else validateChildKeys(children);
        if (hasOwnProperty.call(config, "key")) {
          children = getComponentNameFromType(type);
          var keys = Object.keys(config).filter(function(k) {
            return "key" !== k;
          });
          isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
          didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
            'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
            isStaticChildren,
            children,
            keys,
            children
          ), didWarnAboutKeySpread[children + isStaticChildren] = true);
        }
        children = null;
        void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
        hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
        if ("key" in config) {
          maybeKey = {};
          for (var propName in config)
            "key" !== propName && (maybeKey[propName] = config[propName]);
        } else maybeKey = config;
        children && defineKeyPropWarningGetter(
          maybeKey,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        return ReactElement(
          type,
          children,
          maybeKey,
          getOwner(),
          debugStack,
          debugTask
        );
      }
      function validateChildKeys(node) {
        "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
      }
      var React = require_react(), REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo"), REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = /* @__PURE__ */ Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      React = {
        react_stack_bottom_frame: function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(
        React,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutKeySpread = {};
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsx = function(type, config, maybeKey) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type,
          config,
          maybeKey,
          false,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
      exports.jsxs = function(type, config, maybeKey) {
        var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return jsxDEVImpl(
          type,
          config,
          maybeKey,
          true,
          trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
    })();
  }
});

// portfolio-site/node_modules/next/dist/compiled/react/jsx-runtime.js
var require_jsx_runtime = __commonJS({
  "portfolio-site/node_modules/next/dist/compiled/react/jsx-runtime.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_jsx_runtime_development();
    }
  }
});

// portfolio-site/node_modules/next/dist/compiled/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS({
  "portfolio-site/node_modules/next/dist/compiled/react-dom/cjs/react-dom.development.js"(exports) {
    "use strict";
    (function() {
      function noop() {
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function createPortal$1(children, containerInfo, implementation) {
        var key = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
        try {
          testStringCoercion(key);
          var JSCompiler_inline_result = false;
        } catch (e) {
          JSCompiler_inline_result = true;
        }
        JSCompiler_inline_result && (console.error(
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          "function" === typeof Symbol && Symbol.toStringTag && key[Symbol.toStringTag] || key.constructor.name || "Object"
        ), testStringCoercion(key));
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: null == key ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      function getCrossOriginStringAs(as, input) {
        if ("font" === as) return "";
        if ("string" === typeof input)
          return "use-credentials" === input ? input : "";
      }
      function getValueDescriptorExpectingObjectForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : 'something with type "' + typeof thing + '"';
      }
      function getValueDescriptorExpectingEnumForWarning(thing) {
        return null === thing ? "`null`" : void 0 === thing ? "`undefined`" : "" === thing ? "an empty string" : "string" === typeof thing ? JSON.stringify(thing) : "number" === typeof thing ? "`" + thing + "`" : 'something with type "' + typeof thing + '"';
      }
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React = require_react(), Internals = {
        d: {
          f: noop,
          r: function() {
            throw Error(
              "Invalid form element. requestFormReset must be passed a form that was rendered by React."
            );
          },
          D: noop,
          C: noop,
          L: noop,
          m: noop,
          X: noop,
          S: noop,
          M: noop
        },
        p: 0,
        findDOMNode: null
      }, REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
      "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
        "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"
      );
      exports.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Internals;
      exports.createPortal = function(children, container) {
        var key = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
        if (!container || 1 !== container.nodeType && 9 !== container.nodeType && 11 !== container.nodeType)
          throw Error("Target container is not a DOM element.");
        return createPortal$1(children, container, null, key);
      };
      exports.flushSync = function(fn) {
        var previousTransition = ReactSharedInternals.T, previousUpdatePriority = Internals.p;
        try {
          if (ReactSharedInternals.T = null, Internals.p = 2, fn)
            return fn();
        } finally {
          ReactSharedInternals.T = previousTransition, Internals.p = previousUpdatePriority, Internals.d.f() && console.error(
            "flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."
          );
        }
      };
      exports.preconnect = function(href, options) {
        "string" === typeof href && href ? null != options && "object" !== typeof options ? console.error(
          "ReactDOM.preconnect(): Expected the `options` argument (second) to be an object but encountered %s instead. The only supported option at this time is `crossOrigin` which accepts a string.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : null != options && "string" !== typeof options.crossOrigin && console.error(
          "ReactDOM.preconnect(): Expected the `crossOrigin` option (second argument) to be a string but encountered %s instead. Try removing this option or passing a string value instead.",
          getValueDescriptorExpectingObjectForWarning(options.crossOrigin)
        ) : console.error(
          "ReactDOM.preconnect(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        "string" === typeof href && (options ? (options = options.crossOrigin, options = "string" === typeof options ? "use-credentials" === options ? options : "" : void 0) : options = null, Internals.d.C(href, options));
      };
      exports.prefetchDNS = function(href) {
        if ("string" !== typeof href || !href)
          console.error(
            "ReactDOM.prefetchDNS(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
            getValueDescriptorExpectingObjectForWarning(href)
          );
        else if (1 < arguments.length) {
          var options = arguments[1];
          "object" === typeof options && options.hasOwnProperty("crossOrigin") ? console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. It looks like the you are attempting to set a crossOrigin property for this DNS lookup hint. Browsers do not perform DNS queries using CORS and setting this attribute on the resource hint has no effect. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options)
          ) : console.error(
            "ReactDOM.prefetchDNS(): Expected only one argument, `href`, but encountered %s as a second argument instead. This argument is reserved for future options and is currently disallowed. Try calling ReactDOM.prefetchDNS() with just a single string argument, `href`.",
            getValueDescriptorExpectingEnumForWarning(options)
          );
        }
        "string" === typeof href && Internals.d.D(href);
      };
      exports.preinit = function(href, options) {
        "string" === typeof href && href ? null == options || "object" !== typeof options ? console.error(
          "ReactDOM.preinit(): Expected the `options` argument (second) to be an object with an `as` property describing the type of resource to be preinitialized but encountered %s instead.",
          getValueDescriptorExpectingEnumForWarning(options)
        ) : "style" !== options.as && "script" !== options.as && console.error(
          'ReactDOM.preinit(): Expected the `as` property in the `options` argument (second) to contain a valid value describing the type of resource to be preinitialized but encountered %s instead. Valid values for `as` are "style" and "script".',
          getValueDescriptorExpectingEnumForWarning(options.as)
        ) : console.error(
          "ReactDOM.preinit(): Expected the `href` argument (first) to be a non-empty string but encountered %s instead.",
          getValueDescriptorExpectingObjectForWarning(href)
        );
        if ("string" === typeof href && options && "string" === typeof options.as) {
          var as = options.as, crossOrigin = getCrossOriginStringAs(as, options.crossOrigin), integrity = "string" === typeof options.integrity ? options.integrity : void 0, fetchPriority = "string" === typeof options.fetchPriority ? options.fetchPriority : void 0;
          "style" === as ? Internals.d.S(
            href,
            "string" === typeof options.precedence ? options.precedence : void 0,
            {
              crossOrigin,
              integrity,
              fetchPriority
            }
          ) : "script" === as && Internals.d.X(href, {
            crossOrigin,
            integrity,
            fetchPriority,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0
          });
        }
      };
      exports.preinitModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "script" !== options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingEnumForWarning(options.as) + ".");
        if (encountered)
          console.error(
            "ReactDOM.preinitModule(): Expected up to two arguments, a non-empty `href` string and, optionally, an `options` object with a valid `as` property.%s",
            encountered
          );
        else
          switch (encountered = options && "string" === typeof options.as ? options.as : "script", encountered) {
            case "script":
              break;
            default:
              encountered = getValueDescriptorExpectingEnumForWarning(encountered), console.error(
                'ReactDOM.preinitModule(): Currently the only supported "as" type for this function is "script" but received "%s" instead. This warning was generated for `href` "%s". In the future other module types will be supported, aligning with the import-attributes proposal. Learn more here: (https://github.com/tc39/proposal-import-attributes)',
                encountered,
                href
              );
          }
        if ("string" === typeof href)
          if ("object" === typeof options && null !== options) {
            if (null == options.as || "script" === options.as)
              encountered = getCrossOriginStringAs(
                options.as,
                options.crossOrigin
              ), Internals.d.M(href, {
                crossOrigin: encountered,
                integrity: "string" === typeof options.integrity ? options.integrity : void 0,
                nonce: "string" === typeof options.nonce ? options.nonce : void 0
              });
          } else null == options && Internals.d.M(href);
      };
      exports.preload = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        null == options || "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : "string" === typeof options.as && options.as || (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error(
          'ReactDOM.preload(): Expected two arguments, a non-empty `href` string and an `options` object with an `as` property valid for a `<link rel="preload" as="..." />` tag.%s',
          encountered
        );
        if ("string" === typeof href && "object" === typeof options && null !== options && "string" === typeof options.as) {
          encountered = options.as;
          var crossOrigin = getCrossOriginStringAs(
            encountered,
            options.crossOrigin
          );
          Internals.d.L(href, encountered, {
            crossOrigin,
            integrity: "string" === typeof options.integrity ? options.integrity : void 0,
            nonce: "string" === typeof options.nonce ? options.nonce : void 0,
            type: "string" === typeof options.type ? options.type : void 0,
            fetchPriority: "string" === typeof options.fetchPriority ? options.fetchPriority : void 0,
            referrerPolicy: "string" === typeof options.referrerPolicy ? options.referrerPolicy : void 0,
            imageSrcSet: "string" === typeof options.imageSrcSet ? options.imageSrcSet : void 0,
            imageSizes: "string" === typeof options.imageSizes ? options.imageSizes : void 0,
            media: "string" === typeof options.media ? options.media : void 0
          });
        }
      };
      exports.preloadModule = function(href, options) {
        var encountered = "";
        "string" === typeof href && href || (encountered += " The `href` argument encountered was " + getValueDescriptorExpectingObjectForWarning(href) + ".");
        void 0 !== options && "object" !== typeof options ? encountered += " The `options` argument encountered was " + getValueDescriptorExpectingObjectForWarning(options) + "." : options && "as" in options && "string" !== typeof options.as && (encountered += " The `as` option encountered was " + getValueDescriptorExpectingObjectForWarning(options.as) + ".");
        encountered && console.error(
          'ReactDOM.preloadModule(): Expected two arguments, a non-empty `href` string and, optionally, an `options` object with an `as` property valid for a `<link rel="modulepreload" as="..." />` tag.%s',
          encountered
        );
        "string" === typeof href && (options ? (encountered = getCrossOriginStringAs(
          options.as,
          options.crossOrigin
        ), Internals.d.m(href, {
          as: "string" === typeof options.as && "script" !== options.as ? options.as : void 0,
          crossOrigin: encountered,
          integrity: "string" === typeof options.integrity ? options.integrity : void 0
        })) : Internals.d.m(href));
      };
      exports.requestFormReset = function(form) {
        Internals.d.r(form);
      };
      exports.unstable_batchedUpdates = function(fn, a) {
        return fn(a);
      };
      exports.useFormState = function(action, initialState, permalink) {
        return resolveDispatcher().useFormState(action, initialState, permalink);
      };
      exports.useFormStatus = function() {
        return resolveDispatcher().useHostTransitionStatus();
      };
      exports.version = "19.2.0-canary-0bdb9206-20250818";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// portfolio-site/node_modules/next/dist/compiled/react-dom/index.js
var require_react_dom = __commonJS({
  "portfolio-site/node_modules/next/dist/compiled/react-dom/index.js"(exports, module) {
    "use strict";
    if (false) {
      checkDCE();
      module.exports = null;
    } else {
      module.exports = require_react_dom_development();
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js
var require_head_manager_context_shared_runtime = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/head-manager-context.shared-runtime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "HeadManagerContext", {
      enumerable: true,
      get: function() {
        return HeadManagerContext;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _react = _interop_require_default._(require_react());
    var HeadManagerContext = _react.default.createContext({});
    if (true) {
      HeadManagerContext.displayName = "HeadManagerContext";
    }
  }
});

// portfolio-site/node_modules/next/dist/client/set-attributes-from-props.js
var require_set_attributes_from_props = __commonJS({
  "portfolio-site/node_modules/next/dist/client/set-attributes-from-props.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "setAttributesFromProps", {
      enumerable: true,
      get: function() {
        return setAttributesFromProps;
      }
    });
    var DOMAttributeNames = {
      acceptCharset: "accept-charset",
      className: "class",
      htmlFor: "for",
      httpEquiv: "http-equiv",
      noModule: "noModule"
    };
    var ignoreProps = [
      "onLoad",
      "onReady",
      "dangerouslySetInnerHTML",
      "children",
      "onError",
      "strategy",
      "stylesheets"
    ];
    function isBooleanScriptAttribute(attr) {
      return [
        "async",
        "defer",
        "noModule"
      ].includes(attr);
    }
    function setAttributesFromProps(el, props) {
      for (const [p, value] of Object.entries(props)) {
        if (!props.hasOwnProperty(p)) continue;
        if (ignoreProps.includes(p)) continue;
        if (value === void 0) {
          continue;
        }
        const attr = DOMAttributeNames[p] || p.toLowerCase();
        if (el.tagName === "SCRIPT" && isBooleanScriptAttribute(attr)) {
          ;
          el[attr] = !!value;
        } else {
          el.setAttribute(attr, String(value));
        }
        if (value === false || el.tagName === "SCRIPT" && isBooleanScriptAttribute(attr) && (!value || value === "false")) {
          el.setAttribute(attr, "");
          el.removeAttribute(attr);
        }
      }
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/client/script.js
var require_script = __commonJS({
  "portfolio-site/node_modules/next/dist/client/script.js"(exports, module) {
    "use client";
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      default: function() {
        return _default;
      },
      handleClientScriptLoad: function() {
        return handleClientScriptLoad;
      },
      initScriptLoader: function() {
        return initScriptLoader;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _interop_require_wildcard = require_interop_require_wildcard();
    var _jsxruntime = require_jsx_runtime();
    var _reactdom = _interop_require_default._(require_react_dom());
    var _react = _interop_require_wildcard._(require_react());
    var _headmanagercontextsharedruntime = require_head_manager_context_shared_runtime();
    var _setattributesfromprops = require_set_attributes_from_props();
    var _requestidlecallback = require_request_idle_callback();
    var ScriptCache = /* @__PURE__ */ new Map();
    var LoadCache = /* @__PURE__ */ new Set();
    var insertStylesheets = (stylesheets) => {
      if (_reactdom.default.preinit) {
        stylesheets.forEach((stylesheet) => {
          _reactdom.default.preinit(stylesheet, {
            as: "style"
          });
        });
        return;
      }
      if (typeof window !== "undefined") {
        let head = document.head;
        stylesheets.forEach((stylesheet) => {
          let link = document.createElement("link");
          link.type = "text/css";
          link.rel = "stylesheet";
          link.href = stylesheet;
          head.appendChild(link);
        });
      }
    };
    var loadScript = (props) => {
      const { src, id, onLoad = () => {
      }, onReady = null, dangerouslySetInnerHTML, children = "", strategy = "afterInteractive", onError, stylesheets } = props;
      const cacheKey = id || src;
      if (cacheKey && LoadCache.has(cacheKey)) {
        return;
      }
      if (ScriptCache.has(src)) {
        LoadCache.add(cacheKey);
        ScriptCache.get(src).then(onLoad, onError);
        return;
      }
      const afterLoad = () => {
        if (onReady) {
          onReady();
        }
        LoadCache.add(cacheKey);
      };
      const el = document.createElement("script");
      const loadPromise = new Promise((resolve, reject) => {
        el.addEventListener("load", function(e) {
          resolve();
          if (onLoad) {
            onLoad.call(this, e);
          }
          afterLoad();
        });
        el.addEventListener("error", function(e) {
          reject(e);
        });
      }).catch(function(e) {
        if (onError) {
          onError(e);
        }
      });
      if (dangerouslySetInnerHTML) {
        el.innerHTML = dangerouslySetInnerHTML.__html || "";
        afterLoad();
      } else if (children) {
        el.textContent = typeof children === "string" ? children : Array.isArray(children) ? children.join("") : "";
        afterLoad();
      } else if (src) {
        el.src = src;
        ScriptCache.set(src, loadPromise);
      }
      (0, _setattributesfromprops.setAttributesFromProps)(el, props);
      if (strategy === "worker") {
        el.setAttribute("type", "text/partytown");
      }
      el.setAttribute("data-nscript", strategy);
      if (stylesheets) {
        insertStylesheets(stylesheets);
      }
      document.body.appendChild(el);
    };
    function handleClientScriptLoad(props) {
      const { strategy = "afterInteractive" } = props;
      if (strategy === "lazyOnload") {
        window.addEventListener("load", () => {
          (0, _requestidlecallback.requestIdleCallback)(() => loadScript(props));
        });
      } else {
        loadScript(props);
      }
    }
    function loadLazyScript(props) {
      if (document.readyState === "complete") {
        (0, _requestidlecallback.requestIdleCallback)(() => loadScript(props));
      } else {
        window.addEventListener("load", () => {
          (0, _requestidlecallback.requestIdleCallback)(() => loadScript(props));
        });
      }
    }
    function addBeforeInteractiveToCache() {
      const scripts = [
        ...document.querySelectorAll('[data-nscript="beforeInteractive"]'),
        ...document.querySelectorAll('[data-nscript="beforePageRender"]')
      ];
      scripts.forEach((script) => {
        const cacheKey = script.id || script.getAttribute("src");
        LoadCache.add(cacheKey);
      });
    }
    function initScriptLoader(scriptLoaderItems) {
      scriptLoaderItems.forEach(handleClientScriptLoad);
      addBeforeInteractiveToCache();
    }
    function Script(props) {
      const { id, src = "", onLoad = () => {
      }, onReady = null, strategy = "afterInteractive", onError, stylesheets, ...restProps } = props;
      let { updateScripts, scripts, getIsSsr, appDir, nonce } = (0, _react.useContext)(_headmanagercontextsharedruntime.HeadManagerContext);
      nonce = restProps.nonce || nonce;
      const hasOnReadyEffectCalled = (0, _react.useRef)(false);
      (0, _react.useEffect)(() => {
        const cacheKey = id || src;
        if (!hasOnReadyEffectCalled.current) {
          if (onReady && cacheKey && LoadCache.has(cacheKey)) {
            onReady();
          }
          hasOnReadyEffectCalled.current = true;
        }
      }, [
        onReady,
        id,
        src
      ]);
      const hasLoadScriptEffectCalled = (0, _react.useRef)(false);
      (0, _react.useEffect)(() => {
        if (!hasLoadScriptEffectCalled.current) {
          if (strategy === "afterInteractive") {
            loadScript(props);
          } else if (strategy === "lazyOnload") {
            loadLazyScript(props);
          }
          hasLoadScriptEffectCalled.current = true;
        }
      }, [
        props,
        strategy
      ]);
      if (strategy === "beforeInteractive" || strategy === "worker") {
        if (updateScripts) {
          scripts[strategy] = (scripts[strategy] || []).concat([
            {
              id,
              src,
              onLoad,
              onReady,
              onError,
              ...restProps,
              nonce
            }
          ]);
          updateScripts(scripts);
        } else if (getIsSsr && getIsSsr()) {
          LoadCache.add(id || src);
        } else if (getIsSsr && !getIsSsr()) {
          loadScript({
            ...props,
            nonce
          });
        }
      }
      if (appDir) {
        if (stylesheets) {
          stylesheets.forEach((styleSrc) => {
            _reactdom.default.preinit(styleSrc, {
              as: "style"
            });
          });
        }
        if (strategy === "beforeInteractive") {
          if (!src) {
            if (restProps.dangerouslySetInnerHTML) {
              restProps.children = restProps.dangerouslySetInnerHTML.__html;
              delete restProps.dangerouslySetInnerHTML;
            }
            return (0, _jsxruntime.jsx)("script", {
              nonce,
              dangerouslySetInnerHTML: {
                __html: "(self.__next_s=self.__next_s||[]).push(" + JSON.stringify([
                  0,
                  {
                    ...restProps,
                    id
                  }
                ]) + ")"
              }
            });
          } else {
            _reactdom.default.preload(src, restProps.integrity ? {
              as: "script",
              integrity: restProps.integrity,
              nonce,
              crossOrigin: restProps.crossOrigin
            } : {
              as: "script",
              nonce,
              crossOrigin: restProps.crossOrigin
            });
            return (0, _jsxruntime.jsx)("script", {
              nonce,
              dangerouslySetInnerHTML: {
                __html: "(self.__next_s=self.__next_s||[]).push(" + JSON.stringify([
                  src,
                  {
                    ...restProps,
                    id
                  }
                ]) + ")"
              }
            });
          }
        } else if (strategy === "afterInteractive") {
          if (src) {
            _reactdom.default.preload(src, restProps.integrity ? {
              as: "script",
              integrity: restProps.integrity,
              nonce,
              crossOrigin: restProps.crossOrigin
            } : {
              as: "script",
              nonce,
              crossOrigin: restProps.crossOrigin
            });
          }
        }
      }
      return null;
    }
    Object.defineProperty(Script, "__nextScript", {
      value: true
    });
    var _default = Script;
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/is-plain-object.js
var require_is_plain_object = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/is-plain-object.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      getObjectClassLabel: function() {
        return getObjectClassLabel;
      },
      isPlainObject: function() {
        return isPlainObject;
      }
    });
    function getObjectClassLabel(value) {
      return Object.prototype.toString.call(value);
    }
    function isPlainObject(value) {
      if (getObjectClassLabel(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype.hasOwnProperty("isPrototypeOf");
    }
  }
});

// portfolio-site/node_modules/next/dist/lib/is-error.js
var require_is_error = __commonJS({
  "portfolio-site/node_modules/next/dist/lib/is-error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      /**
      * Checks whether the given value is a NextError.
      * This can be used to print a more detailed error message with properties like `code` & `digest`.
      */
      default: function() {
        return isError;
      },
      getProperError: function() {
        return getProperError;
      }
    });
    var _isplainobject = require_is_plain_object();
    function isError(err) {
      return typeof err === "object" && err !== null && "name" in err && "message" in err;
    }
    function safeStringify(obj) {
      const seen = /* @__PURE__ */ new WeakSet();
      return JSON.stringify(obj, (_key, value) => {
        if (typeof value === "object" && value !== null) {
          if (seen.has(value)) {
            return "[Circular]";
          }
          seen.add(value);
        }
        return value;
      });
    }
    function getProperError(err) {
      if (isError(err)) {
        return err;
      }
      if (true) {
        if (typeof err === "undefined") {
          return Object.defineProperty(new Error("An undefined error was thrown, see here for more info: https://nextjs.org/docs/messages/threw-undefined"), "__NEXT_ERROR_CODE", {
            value: "E98",
            enumerable: false,
            configurable: true
          });
        }
        if (err === null) {
          return Object.defineProperty(new Error("A null error was thrown, see here for more info: https://nextjs.org/docs/messages/threw-undefined"), "__NEXT_ERROR_CODE", {
            value: "E336",
            enumerable: false,
            configurable: true
          });
        }
      }
      return Object.defineProperty(new Error((0, _isplainobject.isPlainObject)(err) ? safeStringify(err) : err + ""), "__NEXT_ERROR_CODE", {
        value: "E394",
        enumerable: false,
        configurable: true
      });
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js
var require_sorted_routes = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/sorted-routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      getSortedRouteObjects: function() {
        return getSortedRouteObjects;
      },
      getSortedRoutes: function() {
        return getSortedRoutes;
      }
    });
    var UrlNode = class _UrlNode {
      insert(urlPath) {
        this._insert(urlPath.split("/").filter(Boolean), [], false);
      }
      smoosh() {
        return this._smoosh();
      }
      _smoosh(prefix) {
        if (prefix === void 0) prefix = "/";
        const childrenPaths = [
          ...this.children.keys()
        ].sort();
        if (this.slugName !== null) {
          childrenPaths.splice(childrenPaths.indexOf("[]"), 1);
        }
        if (this.restSlugName !== null) {
          childrenPaths.splice(childrenPaths.indexOf("[...]"), 1);
        }
        if (this.optionalRestSlugName !== null) {
          childrenPaths.splice(childrenPaths.indexOf("[[...]]"), 1);
        }
        const routes = childrenPaths.map((c) => this.children.get(c)._smoosh("" + prefix + c + "/")).reduce((prev, curr) => [
          ...prev,
          ...curr
        ], []);
        if (this.slugName !== null) {
          routes.push(...this.children.get("[]")._smoosh(prefix + "[" + this.slugName + "]/"));
        }
        if (!this.placeholder) {
          const r = prefix === "/" ? "/" : prefix.slice(0, -1);
          if (this.optionalRestSlugName != null) {
            throw Object.defineProperty(new Error('You cannot define a route with the same specificity as a optional catch-all route ("' + r + '" and "' + r + "[[..." + this.optionalRestSlugName + ']]").'), "__NEXT_ERROR_CODE", {
              value: "E458",
              enumerable: false,
              configurable: true
            });
          }
          routes.unshift(r);
        }
        if (this.restSlugName !== null) {
          routes.push(...this.children.get("[...]")._smoosh(prefix + "[..." + this.restSlugName + "]/"));
        }
        if (this.optionalRestSlugName !== null) {
          routes.push(...this.children.get("[[...]]")._smoosh(prefix + "[[..." + this.optionalRestSlugName + "]]/"));
        }
        return routes;
      }
      _insert(urlPaths, slugNames, isCatchAll) {
        if (urlPaths.length === 0) {
          this.placeholder = false;
          return;
        }
        if (isCatchAll) {
          throw Object.defineProperty(new Error("Catch-all must be the last part of the URL."), "__NEXT_ERROR_CODE", {
            value: "E392",
            enumerable: false,
            configurable: true
          });
        }
        let nextSegment = urlPaths[0];
        if (nextSegment.startsWith("[") && nextSegment.endsWith("]")) {
          let handleSlug = function(previousSlug, nextSlug) {
            if (previousSlug !== null) {
              if (previousSlug !== nextSlug) {
                throw Object.defineProperty(new Error("You cannot use different slug names for the same dynamic path ('" + previousSlug + "' !== '" + nextSlug + "')."), "__NEXT_ERROR_CODE", {
                  value: "E337",
                  enumerable: false,
                  configurable: true
                });
              }
            }
            slugNames.forEach((slug) => {
              if (slug === nextSlug) {
                throw Object.defineProperty(new Error('You cannot have the same slug name "' + nextSlug + '" repeat within a single dynamic path'), "__NEXT_ERROR_CODE", {
                  value: "E247",
                  enumerable: false,
                  configurable: true
                });
              }
              if (slug.replace(/\W/g, "") === nextSegment.replace(/\W/g, "")) {
                throw Object.defineProperty(new Error('You cannot have the slug names "' + slug + '" and "' + nextSlug + '" differ only by non-word symbols within a single dynamic path'), "__NEXT_ERROR_CODE", {
                  value: "E499",
                  enumerable: false,
                  configurable: true
                });
              }
            });
            slugNames.push(nextSlug);
          };
          let segmentName = nextSegment.slice(1, -1);
          let isOptional = false;
          if (segmentName.startsWith("[") && segmentName.endsWith("]")) {
            segmentName = segmentName.slice(1, -1);
            isOptional = true;
          }
          if (segmentName.startsWith("")) {
            throw Object.defineProperty(new Error("Detected a three-dot character ('') at ('" + segmentName + "'). Did you mean ('...')?"), "__NEXT_ERROR_CODE", {
              value: "E147",
              enumerable: false,
              configurable: true
            });
          }
          if (segmentName.startsWith("...")) {
            segmentName = segmentName.substring(3);
            isCatchAll = true;
          }
          if (segmentName.startsWith("[") || segmentName.endsWith("]")) {
            throw Object.defineProperty(new Error("Segment names may not start or end with extra brackets ('" + segmentName + "')."), "__NEXT_ERROR_CODE", {
              value: "E421",
              enumerable: false,
              configurable: true
            });
          }
          if (segmentName.startsWith(".")) {
            throw Object.defineProperty(new Error("Segment names may not start with erroneous periods ('" + segmentName + "')."), "__NEXT_ERROR_CODE", {
              value: "E288",
              enumerable: false,
              configurable: true
            });
          }
          if (isCatchAll) {
            if (isOptional) {
              if (this.restSlugName != null) {
                throw Object.defineProperty(new Error('You cannot use both an required and optional catch-all route at the same level ("[...' + this.restSlugName + ']" and "' + urlPaths[0] + '" ).'), "__NEXT_ERROR_CODE", {
                  value: "E299",
                  enumerable: false,
                  configurable: true
                });
              }
              handleSlug(this.optionalRestSlugName, segmentName);
              this.optionalRestSlugName = segmentName;
              nextSegment = "[[...]]";
            } else {
              if (this.optionalRestSlugName != null) {
                throw Object.defineProperty(new Error('You cannot use both an optional and required catch-all route at the same level ("[[...' + this.optionalRestSlugName + ']]" and "' + urlPaths[0] + '").'), "__NEXT_ERROR_CODE", {
                  value: "E300",
                  enumerable: false,
                  configurable: true
                });
              }
              handleSlug(this.restSlugName, segmentName);
              this.restSlugName = segmentName;
              nextSegment = "[...]";
            }
          } else {
            if (isOptional) {
              throw Object.defineProperty(new Error('Optional route parameters are not yet supported ("' + urlPaths[0] + '").'), "__NEXT_ERROR_CODE", {
                value: "E435",
                enumerable: false,
                configurable: true
              });
            }
            handleSlug(this.slugName, segmentName);
            this.slugName = segmentName;
            nextSegment = "[]";
          }
        }
        if (!this.children.has(nextSegment)) {
          this.children.set(nextSegment, new _UrlNode());
        }
        this.children.get(nextSegment)._insert(urlPaths.slice(1), slugNames, isCatchAll);
      }
      constructor() {
        this.placeholder = true;
        this.children = /* @__PURE__ */ new Map();
        this.slugName = null;
        this.restSlugName = null;
        this.optionalRestSlugName = null;
      }
    };
    function getSortedRoutes(normalizedPages) {
      const root = new UrlNode();
      normalizedPages.forEach((pagePath) => root.insert(pagePath));
      return root.smoosh();
    }
    function getSortedRouteObjects(objects, getter) {
      const indexes = {};
      const pathnames = [];
      for (let i = 0; i < objects.length; i++) {
        const pathname = getter(objects[i]);
        indexes[pathname] = i;
        pathnames[i] = pathname;
      }
      const sorted = getSortedRoutes(pathnames);
      return sorted.map((pathname) => objects[indexes[pathname]]);
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js
var require_ensure_leading_slash = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/page-path/ensure-leading-slash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ensureLeadingSlash", {
      enumerable: true,
      get: function() {
        return ensureLeadingSlash;
      }
    });
    function ensureLeadingSlash(path) {
      return path.startsWith("/") ? path : "/" + path;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/app-paths.js
var require_app_paths = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/app-paths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      normalizeAppPath: function() {
        return normalizeAppPath;
      },
      normalizeRscURL: function() {
        return normalizeRscURL;
      }
    });
    var _ensureleadingslash = require_ensure_leading_slash();
    var _segment = require_segment();
    function normalizeAppPath(route) {
      return (0, _ensureleadingslash.ensureLeadingSlash)(route.split("/").reduce((pathname, segment, index, segments) => {
        if (!segment) {
          return pathname;
        }
        if ((0, _segment.isGroupSegment)(segment)) {
          return pathname;
        }
        if (segment[0] === "@") {
          return pathname;
        }
        if ((segment === "page" || segment === "route") && index === segments.length - 1) {
          return pathname;
        }
        return pathname + "/" + segment;
      }, ""));
    }
    function normalizeRscURL(url) {
      return url.replace(
        /\.rsc($|\?)/,
        // $1 ensures `?` is preserved
        "$1"
      );
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/interception-routes.js
var require_interception_routes = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/interception-routes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      INTERCEPTION_ROUTE_MARKERS: function() {
        return INTERCEPTION_ROUTE_MARKERS;
      },
      extractInterceptionRouteInformation: function() {
        return extractInterceptionRouteInformation;
      },
      isInterceptionRouteAppPath: function() {
        return isInterceptionRouteAppPath;
      }
    });
    var _apppaths = require_app_paths();
    var INTERCEPTION_ROUTE_MARKERS = [
      "(..)(..)",
      "(.)",
      "(..)",
      "(...)"
    ];
    function isInterceptionRouteAppPath(path) {
      return path.split("/").find((segment) => INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))) !== void 0;
    }
    function extractInterceptionRouteInformation(path) {
      let interceptingRoute, marker, interceptedRoute;
      for (const segment of path.split("/")) {
        marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m));
        if (marker) {
          ;
          [interceptingRoute, interceptedRoute] = path.split(marker, 2);
          break;
        }
      }
      if (!interceptingRoute || !marker || !interceptedRoute) {
        throw Object.defineProperty(new Error("Invalid interception route: " + path + ". Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>"), "__NEXT_ERROR_CODE", {
          value: "E269",
          enumerable: false,
          configurable: true
        });
      }
      interceptingRoute = (0, _apppaths.normalizeAppPath)(interceptingRoute);
      switch (marker) {
        case "(.)":
          if (interceptingRoute === "/") {
            interceptedRoute = "/" + interceptedRoute;
          } else {
            interceptedRoute = interceptingRoute + "/" + interceptedRoute;
          }
          break;
        case "(..)":
          if (interceptingRoute === "/") {
            throw Object.defineProperty(new Error("Invalid interception route: " + path + ". Cannot use (..) marker at the root level, use (.) instead."), "__NEXT_ERROR_CODE", {
              value: "E207",
              enumerable: false,
              configurable: true
            });
          }
          interceptedRoute = interceptingRoute.split("/").slice(0, -1).concat(interceptedRoute).join("/");
          break;
        case "(...)":
          interceptedRoute = "/" + interceptedRoute;
          break;
        case "(..)(..)":
          const splitInterceptingRoute = interceptingRoute.split("/");
          if (splitInterceptingRoute.length <= 2) {
            throw Object.defineProperty(new Error("Invalid interception route: " + path + ". Cannot use (..)(..) marker at the root level or one level up."), "__NEXT_ERROR_CODE", {
              value: "E486",
              enumerable: false,
              configurable: true
            });
          }
          interceptedRoute = splitInterceptingRoute.slice(0, -2).concat(interceptedRoute).join("/");
          break;
        default:
          throw Object.defineProperty(new Error("Invariant: unexpected marker"), "__NEXT_ERROR_CODE", {
            value: "E112",
            enumerable: false,
            configurable: true
          });
      }
      return {
        interceptingRoute,
        interceptedRoute
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js
var require_is_dynamic = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/is-dynamic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isDynamicRoute", {
      enumerable: true,
      get: function() {
        return isDynamicRoute;
      }
    });
    var _interceptionroutes = require_interception_routes();
    var TEST_ROUTE = /\/[^/]*\[[^/]+\][^/]*(?=\/|$)/;
    var TEST_STRICT_ROUTE = /\/\[[^/]+\](?=\/|$)/;
    function isDynamicRoute(route, strict) {
      if (strict === void 0) strict = true;
      if ((0, _interceptionroutes.isInterceptionRouteAppPath)(route)) {
        route = (0, _interceptionroutes.extractInterceptionRouteInformation)(route).interceptedRoute;
      }
      if (strict) {
        return TEST_STRICT_ROUTE.test(route);
      }
      return TEST_ROUTE.test(route);
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/index.js
var require_utils = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      getSortedRouteObjects: function() {
        return _sortedroutes.getSortedRouteObjects;
      },
      getSortedRoutes: function() {
        return _sortedroutes.getSortedRoutes;
      },
      isDynamicRoute: function() {
        return _isdynamic.isDynamicRoute;
      }
    });
    var _sortedroutes = require_sorted_routes();
    var _isdynamic = require_is_dynamic();
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js
var require_normalize_path_sep = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/page-path/normalize-path-sep.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "normalizePathSep", {
      enumerable: true,
      get: function() {
        return normalizePathSep;
      }
    });
    function normalizePathSep(path) {
      return path.replace(/\\/g, "/");
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js
var require_denormalize_page_path = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "denormalizePagePath", {
      enumerable: true,
      get: function() {
        return denormalizePagePath;
      }
    });
    var _utils = require_utils();
    var _normalizepathsep = require_normalize_path_sep();
    function denormalizePagePath(page) {
      let _page = (0, _normalizepathsep.normalizePathSep)(page);
      return _page.startsWith("/index/") && !(0, _utils.isDynamicRoute)(_page) ? _page.slice(6) : _page !== "/index" ? _page : "/";
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js
var require_normalize_locale_path = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "normalizeLocalePath", {
      enumerable: true,
      get: function() {
        return normalizeLocalePath;
      }
    });
    var cache = /* @__PURE__ */ new WeakMap();
    function normalizeLocalePath(pathname, locales) {
      if (!locales) return {
        pathname
      };
      let lowercasedLocales = cache.get(locales);
      if (!lowercasedLocales) {
        lowercasedLocales = locales.map((locale) => locale.toLowerCase());
        cache.set(locales, lowercasedLocales);
      }
      let detectedLocale;
      const segments = pathname.split("/", 2);
      if (!segments[1]) return {
        pathname
      };
      const segment = segments[1].toLowerCase();
      const index = lowercasedLocales.indexOf(segment);
      if (index < 0) return {
        pathname
      };
      detectedLocale = locales[index];
      pathname = pathname.slice(detectedLocale.length + 1) || "/";
      return {
        pathname,
        detectedLocale
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/mitt.js
var require_mitt = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/mitt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return mitt;
      }
    });
    function mitt() {
      const all = /* @__PURE__ */ Object.create(null);
      return {
        on(type, handler) {
          ;
          (all[type] || (all[type] = [])).push(handler);
        },
        off(type, handler) {
          if (all[type]) {
            all[type].splice(all[type].indexOf(handler) >>> 0, 1);
          }
        },
        emit(type) {
          for (var _len = arguments.length, evts = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            evts[_key - 1] = arguments[_key];
          }
          ;
          (all[type] || []).slice().map((handler) => {
            handler(...evts);
          });
        }
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/utils.js
var require_utils2 = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      DecodeError: function() {
        return DecodeError;
      },
      MiddlewareNotFoundError: function() {
        return MiddlewareNotFoundError;
      },
      MissingStaticPage: function() {
        return MissingStaticPage;
      },
      NormalizeError: function() {
        return NormalizeError;
      },
      PageNotFoundError: function() {
        return PageNotFoundError;
      },
      SP: function() {
        return SP;
      },
      ST: function() {
        return ST;
      },
      WEB_VITALS: function() {
        return WEB_VITALS;
      },
      execOnce: function() {
        return execOnce;
      },
      getDisplayName: function() {
        return getDisplayName;
      },
      getLocationOrigin: function() {
        return getLocationOrigin;
      },
      getURL: function() {
        return getURL;
      },
      isAbsoluteUrl: function() {
        return isAbsoluteUrl;
      },
      isResSent: function() {
        return isResSent;
      },
      loadGetInitialProps: function() {
        return loadGetInitialProps;
      },
      normalizeRepeatedSlashes: function() {
        return normalizeRepeatedSlashes;
      },
      stringifyError: function() {
        return stringifyError;
      }
    });
    var WEB_VITALS = [
      "CLS",
      "FCP",
      "FID",
      "INP",
      "LCP",
      "TTFB"
    ];
    function execOnce(fn) {
      let used = false;
      let result;
      return function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (!used) {
          used = true;
          result = fn(...args);
        }
        return result;
      };
    }
    var ABSOLUTE_URL_REGEX = /^[a-zA-Z][a-zA-Z\d+\-.]*?:/;
    var isAbsoluteUrl = (url) => ABSOLUTE_URL_REGEX.test(url);
    function getLocationOrigin() {
      const { protocol, hostname, port } = window.location;
      return protocol + "//" + hostname + (port ? ":" + port : "");
    }
    function getURL() {
      const { href } = window.location;
      const origin = getLocationOrigin();
      return href.substring(origin.length);
    }
    function getDisplayName(Component) {
      return typeof Component === "string" ? Component : Component.displayName || Component.name || "Unknown";
    }
    function isResSent(res) {
      return res.finished || res.headersSent;
    }
    function normalizeRepeatedSlashes(url) {
      const urlParts = url.split("?");
      const urlNoQuery = urlParts[0];
      return urlNoQuery.replace(/\\/g, "/").replace(/\/\/+/g, "/") + (urlParts[1] ? "?" + urlParts.slice(1).join("?") : "");
    }
    async function loadGetInitialProps(App, ctx) {
      if (true) {
        var _App_prototype;
        if ((_App_prototype = App.prototype) == null ? void 0 : _App_prototype.getInitialProps) {
          const message = '"' + getDisplayName(App) + '.getInitialProps()" is defined as an instance method - visit https://nextjs.org/docs/messages/get-initial-props-as-an-instance-method for more information.';
          throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
          });
        }
      }
      const res = ctx.res || ctx.ctx && ctx.ctx.res;
      if (!App.getInitialProps) {
        if (ctx.ctx && ctx.Component) {
          return {
            pageProps: await loadGetInitialProps(ctx.Component, ctx.ctx)
          };
        }
        return {};
      }
      const props = await App.getInitialProps(ctx);
      if (res && isResSent(res)) {
        return props;
      }
      if (!props) {
        const message = '"' + getDisplayName(App) + '.getInitialProps()" should resolve to an object. But found "' + props + '" instead.';
        throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
          value: "E394",
          enumerable: false,
          configurable: true
        });
      }
      if (true) {
        if (Object.keys(props).length === 0 && !ctx.ctx) {
          console.warn("" + getDisplayName(App) + " returned an empty object from `getInitialProps`. This de-optimizes and prevents automatic static optimization. https://nextjs.org/docs/messages/empty-object-getInitialProps");
        }
      }
      return props;
    }
    var SP = typeof performance !== "undefined";
    var ST = SP && [
      "mark",
      "measure",
      "getEntriesByName"
    ].every((method) => typeof performance[method] === "function");
    var DecodeError = class extends Error {
    };
    var NormalizeError = class extends Error {
    };
    var PageNotFoundError = class extends Error {
      constructor(page) {
        super();
        this.code = "ENOENT";
        this.name = "PageNotFoundError";
        this.message = "Cannot find module for page: " + page;
      }
    };
    var MissingStaticPage = class extends Error {
      constructor(page, message) {
        super();
        this.message = "Failed to load static file for page: " + page + " " + message;
      }
    };
    var MiddlewareNotFoundError = class extends Error {
      constructor() {
        super();
        this.code = "ENOENT";
        this.message = "Cannot find the middleware module";
      }
    };
    function stringifyError(error) {
      return JSON.stringify({
        message: error.message,
        stack: error.stack
      });
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/querystring.js
var require_querystring = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/querystring.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      assign: function() {
        return assign;
      },
      searchParamsToUrlQuery: function() {
        return searchParamsToUrlQuery;
      },
      urlQueryToSearchParams: function() {
        return urlQueryToSearchParams;
      }
    });
    function searchParamsToUrlQuery(searchParams) {
      const query = {};
      for (const [key, value] of searchParams.entries()) {
        const existing = query[key];
        if (typeof existing === "undefined") {
          query[key] = value;
        } else if (Array.isArray(existing)) {
          existing.push(value);
        } else {
          query[key] = [
            existing,
            value
          ];
        }
      }
      return query;
    }
    function stringifyUrlQueryParam(param) {
      if (typeof param === "string") {
        return param;
      }
      if (typeof param === "number" && !isNaN(param) || typeof param === "boolean") {
        return String(param);
      } else {
        return "";
      }
    }
    function urlQueryToSearchParams(query) {
      const searchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(query)) {
        if (Array.isArray(value)) {
          for (const item of value) {
            searchParams.append(key, stringifyUrlQueryParam(item));
          }
        } else {
          searchParams.set(key, stringifyUrlQueryParam(value));
        }
      }
      return searchParams;
    }
    function assign(target) {
      for (var _len = arguments.length, searchParamsList = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        searchParamsList[_key - 1] = arguments[_key];
      }
      for (const searchParams of searchParamsList) {
        for (const key of searchParams.keys()) {
          target.delete(key);
        }
        for (const [key, value] of searchParams.entries()) {
          target.append(key, value);
        }
      }
      return target;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js
var require_parse_relative_url = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "parseRelativeUrl", {
      enumerable: true,
      get: function() {
        return parseRelativeUrl;
      }
    });
    var _utils = require_utils2();
    var _querystring = require_querystring();
    function parseRelativeUrl(url, base, parseQuery) {
      if (parseQuery === void 0) parseQuery = true;
      const globalBase = new URL(typeof window === "undefined" ? "http://n" : (0, _utils.getLocationOrigin)());
      const resolvedBase = base ? new URL(base, globalBase) : url.startsWith(".") ? new URL(typeof window === "undefined" ? "http://n" : window.location.href) : globalBase;
      const { pathname, searchParams, search, hash, href, origin } = new URL(url, resolvedBase);
      if (origin !== globalBase.origin) {
        throw Object.defineProperty(new Error("invariant: invalid relative URL, router received " + url), "__NEXT_ERROR_CODE", {
          value: "E159",
          enumerable: false,
          configurable: true
        });
      }
      return {
        pathname,
        query: parseQuery ? (0, _querystring.searchParamsToUrlQuery)(searchParams) : void 0,
        search,
        hash,
        href: href.slice(origin.length),
        // We don't know for relative URLs at this point since we set a custom, internal
        // base that isn't surfaced to users.
        slashes: void 0
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/compiled/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
  "portfolio-site/node_modules/next/dist/compiled/path-to-regexp/index.js"(exports, module) {
    (() => {
      "use strict";
      if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
      var e = {};
      (() => {
        var n = e;
        Object.defineProperty(n, "__esModule", { value: true });
        n.pathToRegexp = n.tokensToRegexp = n.regexpToFunction = n.match = n.tokensToFunction = n.compile = n.parse = void 0;
        function lexer(e2) {
          var n2 = [];
          var r = 0;
          while (r < e2.length) {
            var t = e2[r];
            if (t === "*" || t === "+" || t === "?") {
              n2.push({ type: "MODIFIER", index: r, value: e2[r++] });
              continue;
            }
            if (t === "\\") {
              n2.push({ type: "ESCAPED_CHAR", index: r++, value: e2[r++] });
              continue;
            }
            if (t === "{") {
              n2.push({ type: "OPEN", index: r, value: e2[r++] });
              continue;
            }
            if (t === "}") {
              n2.push({ type: "CLOSE", index: r, value: e2[r++] });
              continue;
            }
            if (t === ":") {
              var a = "";
              var i = r + 1;
              while (i < e2.length) {
                var o = e2.charCodeAt(i);
                if (o >= 48 && o <= 57 || o >= 65 && o <= 90 || o >= 97 && o <= 122 || o === 95) {
                  a += e2[i++];
                  continue;
                }
                break;
              }
              if (!a) throw new TypeError("Missing parameter name at ".concat(r));
              n2.push({ type: "NAME", index: r, value: a });
              r = i;
              continue;
            }
            if (t === "(") {
              var c = 1;
              var f = "";
              var i = r + 1;
              if (e2[i] === "?") {
                throw new TypeError('Pattern cannot start with "?" at '.concat(i));
              }
              while (i < e2.length) {
                if (e2[i] === "\\") {
                  f += e2[i++] + e2[i++];
                  continue;
                }
                if (e2[i] === ")") {
                  c--;
                  if (c === 0) {
                    i++;
                    break;
                  }
                } else if (e2[i] === "(") {
                  c++;
                  if (e2[i + 1] !== "?") {
                    throw new TypeError("Capturing groups are not allowed at ".concat(i));
                  }
                }
                f += e2[i++];
              }
              if (c) throw new TypeError("Unbalanced pattern at ".concat(r));
              if (!f) throw new TypeError("Missing pattern at ".concat(r));
              n2.push({ type: "PATTERN", index: r, value: f });
              r = i;
              continue;
            }
            n2.push({ type: "CHAR", index: r, value: e2[r++] });
          }
          n2.push({ type: "END", index: r, value: "" });
          return n2;
        }
        function parse(e2, n2) {
          if (n2 === void 0) {
            n2 = {};
          }
          var r = lexer(e2);
          var t = n2.prefixes, a = t === void 0 ? "./" : t, i = n2.delimiter, o = i === void 0 ? "/#?" : i;
          var c = [];
          var f = 0;
          var u = 0;
          var p = "";
          var tryConsume = function(e3) {
            if (u < r.length && r[u].type === e3) return r[u++].value;
          };
          var mustConsume = function(e3) {
            var n3 = tryConsume(e3);
            if (n3 !== void 0) return n3;
            var t2 = r[u], a2 = t2.type, i2 = t2.index;
            throw new TypeError("Unexpected ".concat(a2, " at ").concat(i2, ", expected ").concat(e3));
          };
          var consumeText = function() {
            var e3 = "";
            var n3;
            while (n3 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")) {
              e3 += n3;
            }
            return e3;
          };
          var isSafe = function(e3) {
            for (var n3 = 0, r2 = o; n3 < r2.length; n3++) {
              var t2 = r2[n3];
              if (e3.indexOf(t2) > -1) return true;
            }
            return false;
          };
          var safePattern = function(e3) {
            var n3 = c[c.length - 1];
            var r2 = e3 || (n3 && typeof n3 === "string" ? n3 : "");
            if (n3 && !r2) {
              throw new TypeError('Must have text between two parameters, missing text after "'.concat(n3.name, '"'));
            }
            if (!r2 || isSafe(r2)) return "[^".concat(escapeString(o), "]+?");
            return "(?:(?!".concat(escapeString(r2), ")[^").concat(escapeString(o), "])+?");
          };
          while (u < r.length) {
            var v = tryConsume("CHAR");
            var s = tryConsume("NAME");
            var d = tryConsume("PATTERN");
            if (s || d) {
              var g = v || "";
              if (a.indexOf(g) === -1) {
                p += g;
                g = "";
              }
              if (p) {
                c.push(p);
                p = "";
              }
              c.push({ name: s || f++, prefix: g, suffix: "", pattern: d || safePattern(g), modifier: tryConsume("MODIFIER") || "" });
              continue;
            }
            var x = v || tryConsume("ESCAPED_CHAR");
            if (x) {
              p += x;
              continue;
            }
            if (p) {
              c.push(p);
              p = "";
            }
            var h = tryConsume("OPEN");
            if (h) {
              var g = consumeText();
              var l = tryConsume("NAME") || "";
              var m = tryConsume("PATTERN") || "";
              var T = consumeText();
              mustConsume("CLOSE");
              c.push({ name: l || (m ? f++ : ""), pattern: l && !m ? safePattern(g) : m, prefix: g, suffix: T, modifier: tryConsume("MODIFIER") || "" });
              continue;
            }
            mustConsume("END");
          }
          return c;
        }
        n.parse = parse;
        function compile(e2, n2) {
          return tokensToFunction(parse(e2, n2), n2);
        }
        n.compile = compile;
        function tokensToFunction(e2, n2) {
          if (n2 === void 0) {
            n2 = {};
          }
          var r = flags(n2);
          var t = n2.encode, a = t === void 0 ? function(e3) {
            return e3;
          } : t, i = n2.validate, o = i === void 0 ? true : i;
          var c = e2.map((function(e3) {
            if (typeof e3 === "object") {
              return new RegExp("^(?:".concat(e3.pattern, ")$"), r);
            }
          }));
          return function(n3) {
            var r2 = "";
            for (var t2 = 0; t2 < e2.length; t2++) {
              var i2 = e2[t2];
              if (typeof i2 === "string") {
                r2 += i2;
                continue;
              }
              var f = n3 ? n3[i2.name] : void 0;
              var u = i2.modifier === "?" || i2.modifier === "*";
              var p = i2.modifier === "*" || i2.modifier === "+";
              if (Array.isArray(f)) {
                if (!p) {
                  throw new TypeError('Expected "'.concat(i2.name, '" to not repeat, but got an array'));
                }
                if (f.length === 0) {
                  if (u) continue;
                  throw new TypeError('Expected "'.concat(i2.name, '" to not be empty'));
                }
                for (var v = 0; v < f.length; v++) {
                  var s = a(f[v], i2);
                  if (o && !c[t2].test(s)) {
                    throw new TypeError('Expected all "'.concat(i2.name, '" to match "').concat(i2.pattern, '", but got "').concat(s, '"'));
                  }
                  r2 += i2.prefix + s + i2.suffix;
                }
                continue;
              }
              if (typeof f === "string" || typeof f === "number") {
                var s = a(String(f), i2);
                if (o && !c[t2].test(s)) {
                  throw new TypeError('Expected "'.concat(i2.name, '" to match "').concat(i2.pattern, '", but got "').concat(s, '"'));
                }
                r2 += i2.prefix + s + i2.suffix;
                continue;
              }
              if (u) continue;
              var d = p ? "an array" : "a string";
              throw new TypeError('Expected "'.concat(i2.name, '" to be ').concat(d));
            }
            return r2;
          };
        }
        n.tokensToFunction = tokensToFunction;
        function match(e2, n2) {
          var r = [];
          var t = pathToRegexp(e2, r, n2);
          return regexpToFunction(t, r, n2);
        }
        n.match = match;
        function regexpToFunction(e2, n2, r) {
          if (r === void 0) {
            r = {};
          }
          var t = r.decode, a = t === void 0 ? function(e3) {
            return e3;
          } : t;
          return function(r2) {
            var t2 = e2.exec(r2);
            if (!t2) return false;
            var i = t2[0], o = t2.index;
            var c = /* @__PURE__ */ Object.create(null);
            var _loop_1 = function(e3) {
              if (t2[e3] === void 0) return "continue";
              var r3 = n2[e3 - 1];
              if (r3.modifier === "*" || r3.modifier === "+") {
                c[r3.name] = t2[e3].split(r3.prefix + r3.suffix).map((function(e4) {
                  return a(e4, r3);
                }));
              } else {
                c[r3.name] = a(t2[e3], r3);
              }
            };
            for (var f = 1; f < t2.length; f++) {
              _loop_1(f);
            }
            return { path: i, index: o, params: c };
          };
        }
        n.regexpToFunction = regexpToFunction;
        function escapeString(e2) {
          return e2.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
        }
        function flags(e2) {
          return e2 && e2.sensitive ? "" : "i";
        }
        function regexpToRegexp(e2, n2) {
          if (!n2) return e2;
          var r = /\((?:\?<(.*?)>)?(?!\?)/g;
          var t = 0;
          var a = r.exec(e2.source);
          while (a) {
            n2.push({ name: a[1] || t++, prefix: "", suffix: "", modifier: "", pattern: "" });
            a = r.exec(e2.source);
          }
          return e2;
        }
        function arrayToRegexp(e2, n2, r) {
          var t = e2.map((function(e3) {
            return pathToRegexp(e3, n2, r).source;
          }));
          return new RegExp("(?:".concat(t.join("|"), ")"), flags(r));
        }
        function stringToRegexp(e2, n2, r) {
          return tokensToRegexp(parse(e2, r), n2, r);
        }
        function tokensToRegexp(e2, n2, r) {
          if (r === void 0) {
            r = {};
          }
          var t = r.strict, a = t === void 0 ? false : t, i = r.start, o = i === void 0 ? true : i, c = r.end, f = c === void 0 ? true : c, u = r.encode, p = u === void 0 ? function(e3) {
            return e3;
          } : u, v = r.delimiter, s = v === void 0 ? "/#?" : v, d = r.endsWith, g = d === void 0 ? "" : d;
          var x = "[".concat(escapeString(g), "]|$");
          var h = "[".concat(escapeString(s), "]");
          var l = o ? "^" : "";
          for (var m = 0, T = e2; m < T.length; m++) {
            var E = T[m];
            if (typeof E === "string") {
              l += escapeString(p(E));
            } else {
              var w = escapeString(p(E.prefix));
              var y = escapeString(p(E.suffix));
              if (E.pattern) {
                if (n2) n2.push(E);
                if (w || y) {
                  if (E.modifier === "+" || E.modifier === "*") {
                    var R = E.modifier === "*" ? "?" : "";
                    l += "(?:".concat(w, "((?:").concat(E.pattern, ")(?:").concat(y).concat(w, "(?:").concat(E.pattern, "))*)").concat(y, ")").concat(R);
                  } else {
                    l += "(?:".concat(w, "(").concat(E.pattern, ")").concat(y, ")").concat(E.modifier);
                  }
                } else {
                  if (E.modifier === "+" || E.modifier === "*") {
                    throw new TypeError('Can not repeat "'.concat(E.name, '" without a prefix and suffix'));
                  }
                  l += "(".concat(E.pattern, ")").concat(E.modifier);
                }
              } else {
                l += "(?:".concat(w).concat(y, ")").concat(E.modifier);
              }
            }
          }
          if (f) {
            if (!a) l += "".concat(h, "?");
            l += !r.endsWith ? "$" : "(?=".concat(x, ")");
          } else {
            var A = e2[e2.length - 1];
            var _ = typeof A === "string" ? h.indexOf(A[A.length - 1]) > -1 : A === void 0;
            if (!a) {
              l += "(?:".concat(h, "(?=").concat(x, "))?");
            }
            if (!_) {
              l += "(?=".concat(h, "|").concat(x, ")");
            }
          }
          return new RegExp(l, flags(r));
        }
        n.tokensToRegexp = tokensToRegexp;
        function pathToRegexp(e2, n2, r) {
          if (e2 instanceof RegExp) return regexpToRegexp(e2, n2);
          if (Array.isArray(e2)) return arrayToRegexp(e2, n2, r);
          return stringToRegexp(e2, n2, r);
        }
        n.pathToRegexp = pathToRegexp;
      })();
      module.exports = e;
    })();
  }
});

// portfolio-site/node_modules/next/dist/lib/route-pattern-normalizer.js
var require_route_pattern_normalizer = __commonJS({
  "portfolio-site/node_modules/next/dist/lib/route-pattern-normalizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      hasAdjacentParameterIssues: function() {
        return hasAdjacentParameterIssues;
      },
      normalizeAdjacentParameters: function() {
        return normalizeAdjacentParameters;
      },
      normalizeTokensForRegexp: function() {
        return normalizeTokensForRegexp;
      },
      stripParameterSeparators: function() {
        return stripParameterSeparators;
      }
    });
    var PARAM_SEPARATOR = "_NEXTSEP_";
    function hasAdjacentParameterIssues(route) {
      if (typeof route !== "string") return false;
      if (/\/\(\.{1,3}\):[^/\s]+/.test(route)) {
        return true;
      }
      if (/:[a-zA-Z_][a-zA-Z0-9_]*:[a-zA-Z_][a-zA-Z0-9_]*/.test(route)) {
        return true;
      }
      return false;
    }
    function normalizeAdjacentParameters(route) {
      let normalized = route;
      normalized = normalized.replace(/(\([^)]*\)):([^/\s]+)/g, `$1${PARAM_SEPARATOR}:$2`);
      normalized = normalized.replace(/:([^:/\s)]+)(?=:)/g, `:$1${PARAM_SEPARATOR}`);
      return normalized;
    }
    function normalizeTokensForRegexp(tokens) {
      return tokens.map((token) => {
        if (typeof token === "object" && token !== null && // Not all token objects have 'modifier' property (e.g., simple text tokens)
        "modifier" in token && // Only repeating modifiers (* or +) cause the validation error
        // Other modifiers like '?' (optional) are fine
        (token.modifier === "*" || token.modifier === "+") && // Token objects can have different shapes depending on route pattern
        "prefix" in token && "suffix" in token && // Both prefix and suffix must be empty strings
        // This is what causes the validation error in path-to-regexp
        token.prefix === "" && token.suffix === "") {
          return {
            ...token,
            prefix: "/"
          };
        }
        return token;
      });
    }
    function stripParameterSeparators(params) {
      const cleaned = {};
      for (const [key, value] of Object.entries(params)) {
        if (typeof value === "string") {
          cleaned[key] = value.replace(new RegExp(`^${PARAM_SEPARATOR}`), "");
        } else if (Array.isArray(value)) {
          cleaned[key] = value.map((item) => typeof item === "string" ? item.replace(new RegExp(`^${PARAM_SEPARATOR}`), "") : item);
        } else {
          cleaned[key] = value;
        }
      }
      return cleaned;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/route-match-utils.js
var require_route_match_utils = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/route-match-utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      safeCompile: function() {
        return safeCompile;
      },
      safePathToRegexp: function() {
        return safePathToRegexp;
      },
      safeRegexpToFunction: function() {
        return safeRegexpToFunction;
      },
      safeRouteMatcher: function() {
        return safeRouteMatcher;
      }
    });
    var _pathtoregexp = require_path_to_regexp();
    var _routepatternnormalizer = require_route_pattern_normalizer();
    function safePathToRegexp(route, keys, options) {
      if (typeof route !== "string") {
        return (0, _pathtoregexp.pathToRegexp)(route, keys, options);
      }
      const needsNormalization = (0, _routepatternnormalizer.hasAdjacentParameterIssues)(route);
      const routeToUse = needsNormalization ? (0, _routepatternnormalizer.normalizeAdjacentParameters)(route) : route;
      try {
        return (0, _pathtoregexp.pathToRegexp)(routeToUse, keys, options);
      } catch (error) {
        if (!needsNormalization) {
          try {
            const normalizedRoute = (0, _routepatternnormalizer.normalizeAdjacentParameters)(route);
            return (0, _pathtoregexp.pathToRegexp)(normalizedRoute, keys, options);
          } catch (retryError) {
            throw error;
          }
        }
        throw error;
      }
    }
    function safeCompile(route, options) {
      const needsNormalization = (0, _routepatternnormalizer.hasAdjacentParameterIssues)(route);
      const routeToUse = needsNormalization ? (0, _routepatternnormalizer.normalizeAdjacentParameters)(route) : route;
      try {
        return (0, _pathtoregexp.compile)(routeToUse, options);
      } catch (error) {
        if (!needsNormalization) {
          try {
            const normalizedRoute = (0, _routepatternnormalizer.normalizeAdjacentParameters)(route);
            return (0, _pathtoregexp.compile)(normalizedRoute, options);
          } catch (retryError) {
            throw error;
          }
        }
        throw error;
      }
    }
    function safeRegexpToFunction(regexp, keys) {
      const originalMatcher = (0, _pathtoregexp.regexpToFunction)(regexp, keys || []);
      return (pathname) => {
        const result = originalMatcher(pathname);
        if (!result) return false;
        return {
          ...result,
          params: (0, _routepatternnormalizer.stripParameterSeparators)(result.params)
        };
      };
    }
    function safeRouteMatcher(matcherFn) {
      return (pathname) => {
        const result = matcherFn(pathname);
        if (!result) return false;
        return (0, _routepatternnormalizer.stripParameterSeparators)(result);
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/route-matcher.js
var require_route_matcher = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/route-matcher.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getRouteMatcher", {
      enumerable: true,
      get: function() {
        return getRouteMatcher;
      }
    });
    var _utils = require_utils2();
    var _routematchutils = require_route_match_utils();
    function getRouteMatcher(param) {
      let { re, groups } = param;
      const rawMatcher = (pathname) => {
        const routeMatch = re.exec(pathname);
        if (!routeMatch) return false;
        const decode = (param2) => {
          try {
            return decodeURIComponent(param2);
          } catch (e) {
            throw Object.defineProperty(new _utils.DecodeError("failed to decode param"), "__NEXT_ERROR_CODE", {
              value: "E528",
              enumerable: false,
              configurable: true
            });
          }
        };
        const params = {};
        for (const [key, group] of Object.entries(groups)) {
          const match = routeMatch[group.pos];
          if (match !== void 0) {
            if (group.repeat) {
              params[key] = match.split("/").map((entry) => decode(entry));
            } else {
              params[key] = decode(match);
            }
          }
        }
        return params;
      };
      return (0, _routematchutils.safeRouteMatcher)(rawMatcher);
    }
  }
});

// portfolio-site/node_modules/next/dist/lib/constants.js
var require_constants = __commonJS({
  "portfolio-site/node_modules/next/dist/lib/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      ACTION_SUFFIX: function() {
        return ACTION_SUFFIX;
      },
      APP_DIR_ALIAS: function() {
        return APP_DIR_ALIAS;
      },
      CACHE_ONE_YEAR: function() {
        return CACHE_ONE_YEAR;
      },
      DOT_NEXT_ALIAS: function() {
        return DOT_NEXT_ALIAS;
      },
      ESLINT_DEFAULT_DIRS: function() {
        return ESLINT_DEFAULT_DIRS;
      },
      GSP_NO_RETURNED_VALUE: function() {
        return GSP_NO_RETURNED_VALUE;
      },
      GSSP_COMPONENT_MEMBER_ERROR: function() {
        return GSSP_COMPONENT_MEMBER_ERROR;
      },
      GSSP_NO_RETURNED_VALUE: function() {
        return GSSP_NO_RETURNED_VALUE;
      },
      HTML_CONTENT_TYPE_HEADER: function() {
        return HTML_CONTENT_TYPE_HEADER;
      },
      INFINITE_CACHE: function() {
        return INFINITE_CACHE;
      },
      INSTRUMENTATION_HOOK_FILENAME: function() {
        return INSTRUMENTATION_HOOK_FILENAME;
      },
      JSON_CONTENT_TYPE_HEADER: function() {
        return JSON_CONTENT_TYPE_HEADER;
      },
      MATCHED_PATH_HEADER: function() {
        return MATCHED_PATH_HEADER;
      },
      MIDDLEWARE_FILENAME: function() {
        return MIDDLEWARE_FILENAME;
      },
      MIDDLEWARE_LOCATION_REGEXP: function() {
        return MIDDLEWARE_LOCATION_REGEXP;
      },
      NEXT_BODY_SUFFIX: function() {
        return NEXT_BODY_SUFFIX;
      },
      NEXT_CACHE_IMPLICIT_TAG_ID: function() {
        return NEXT_CACHE_IMPLICIT_TAG_ID;
      },
      NEXT_CACHE_REVALIDATED_TAGS_HEADER: function() {
        return NEXT_CACHE_REVALIDATED_TAGS_HEADER;
      },
      NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER: function() {
        return NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER;
      },
      NEXT_CACHE_SOFT_TAG_MAX_LENGTH: function() {
        return NEXT_CACHE_SOFT_TAG_MAX_LENGTH;
      },
      NEXT_CACHE_TAGS_HEADER: function() {
        return NEXT_CACHE_TAGS_HEADER;
      },
      NEXT_CACHE_TAG_MAX_ITEMS: function() {
        return NEXT_CACHE_TAG_MAX_ITEMS;
      },
      NEXT_CACHE_TAG_MAX_LENGTH: function() {
        return NEXT_CACHE_TAG_MAX_LENGTH;
      },
      NEXT_DATA_SUFFIX: function() {
        return NEXT_DATA_SUFFIX;
      },
      NEXT_INTERCEPTION_MARKER_PREFIX: function() {
        return NEXT_INTERCEPTION_MARKER_PREFIX;
      },
      NEXT_META_SUFFIX: function() {
        return NEXT_META_SUFFIX;
      },
      NEXT_QUERY_PARAM_PREFIX: function() {
        return NEXT_QUERY_PARAM_PREFIX;
      },
      NEXT_RESUME_HEADER: function() {
        return NEXT_RESUME_HEADER;
      },
      NON_STANDARD_NODE_ENV: function() {
        return NON_STANDARD_NODE_ENV;
      },
      PAGES_DIR_ALIAS: function() {
        return PAGES_DIR_ALIAS;
      },
      PRERENDER_REVALIDATE_HEADER: function() {
        return PRERENDER_REVALIDATE_HEADER;
      },
      PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER: function() {
        return PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER;
      },
      PUBLIC_DIR_MIDDLEWARE_CONFLICT: function() {
        return PUBLIC_DIR_MIDDLEWARE_CONFLICT;
      },
      ROOT_DIR_ALIAS: function() {
        return ROOT_DIR_ALIAS;
      },
      RSC_ACTION_CLIENT_WRAPPER_ALIAS: function() {
        return RSC_ACTION_CLIENT_WRAPPER_ALIAS;
      },
      RSC_ACTION_ENCRYPTION_ALIAS: function() {
        return RSC_ACTION_ENCRYPTION_ALIAS;
      },
      RSC_ACTION_PROXY_ALIAS: function() {
        return RSC_ACTION_PROXY_ALIAS;
      },
      RSC_ACTION_VALIDATE_ALIAS: function() {
        return RSC_ACTION_VALIDATE_ALIAS;
      },
      RSC_CACHE_WRAPPER_ALIAS: function() {
        return RSC_CACHE_WRAPPER_ALIAS;
      },
      RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS: function() {
        return RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS;
      },
      RSC_MOD_REF_PROXY_ALIAS: function() {
        return RSC_MOD_REF_PROXY_ALIAS;
      },
      RSC_PREFETCH_SUFFIX: function() {
        return RSC_PREFETCH_SUFFIX;
      },
      RSC_SEGMENTS_DIR_SUFFIX: function() {
        return RSC_SEGMENTS_DIR_SUFFIX;
      },
      RSC_SEGMENT_SUFFIX: function() {
        return RSC_SEGMENT_SUFFIX;
      },
      RSC_SUFFIX: function() {
        return RSC_SUFFIX;
      },
      SERVER_PROPS_EXPORT_ERROR: function() {
        return SERVER_PROPS_EXPORT_ERROR;
      },
      SERVER_PROPS_GET_INIT_PROPS_CONFLICT: function() {
        return SERVER_PROPS_GET_INIT_PROPS_CONFLICT;
      },
      SERVER_PROPS_SSG_CONFLICT: function() {
        return SERVER_PROPS_SSG_CONFLICT;
      },
      SERVER_RUNTIME: function() {
        return SERVER_RUNTIME;
      },
      SSG_FALLBACK_EXPORT_ERROR: function() {
        return SSG_FALLBACK_EXPORT_ERROR;
      },
      SSG_GET_INITIAL_PROPS_CONFLICT: function() {
        return SSG_GET_INITIAL_PROPS_CONFLICT;
      },
      STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR: function() {
        return STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR;
      },
      TEXT_PLAIN_CONTENT_TYPE_HEADER: function() {
        return TEXT_PLAIN_CONTENT_TYPE_HEADER;
      },
      UNSTABLE_REVALIDATE_RENAME_ERROR: function() {
        return UNSTABLE_REVALIDATE_RENAME_ERROR;
      },
      WEBPACK_LAYERS: function() {
        return WEBPACK_LAYERS;
      },
      WEBPACK_RESOURCE_QUERIES: function() {
        return WEBPACK_RESOURCE_QUERIES;
      }
    });
    var TEXT_PLAIN_CONTENT_TYPE_HEADER = "text/plain";
    var HTML_CONTENT_TYPE_HEADER = "text/html; charset=utf-8";
    var JSON_CONTENT_TYPE_HEADER = "application/json; charset=utf-8";
    var NEXT_QUERY_PARAM_PREFIX = "nxtP";
    var NEXT_INTERCEPTION_MARKER_PREFIX = "nxtI";
    var MATCHED_PATH_HEADER = "x-matched-path";
    var PRERENDER_REVALIDATE_HEADER = "x-prerender-revalidate";
    var PRERENDER_REVALIDATE_ONLY_GENERATED_HEADER = "x-prerender-revalidate-if-generated";
    var RSC_PREFETCH_SUFFIX = ".prefetch.rsc";
    var RSC_SEGMENTS_DIR_SUFFIX = ".segments";
    var RSC_SEGMENT_SUFFIX = ".segment.rsc";
    var RSC_SUFFIX = ".rsc";
    var ACTION_SUFFIX = ".action";
    var NEXT_DATA_SUFFIX = ".json";
    var NEXT_META_SUFFIX = ".meta";
    var NEXT_BODY_SUFFIX = ".body";
    var NEXT_CACHE_TAGS_HEADER = "x-next-cache-tags";
    var NEXT_CACHE_REVALIDATED_TAGS_HEADER = "x-next-revalidated-tags";
    var NEXT_CACHE_REVALIDATE_TAG_TOKEN_HEADER = "x-next-revalidate-tag-token";
    var NEXT_RESUME_HEADER = "next-resume";
    var NEXT_CACHE_TAG_MAX_ITEMS = 128;
    var NEXT_CACHE_TAG_MAX_LENGTH = 256;
    var NEXT_CACHE_SOFT_TAG_MAX_LENGTH = 1024;
    var NEXT_CACHE_IMPLICIT_TAG_ID = "_N_T_";
    var CACHE_ONE_YEAR = 31536e3;
    var INFINITE_CACHE = 4294967294;
    var MIDDLEWARE_FILENAME = "middleware";
    var MIDDLEWARE_LOCATION_REGEXP = `(?:src/)?${MIDDLEWARE_FILENAME}`;
    var INSTRUMENTATION_HOOK_FILENAME = "instrumentation";
    var PAGES_DIR_ALIAS = "private-next-pages";
    var DOT_NEXT_ALIAS = "private-dot-next";
    var ROOT_DIR_ALIAS = "private-next-root-dir";
    var APP_DIR_ALIAS = "private-next-app-dir";
    var RSC_MOD_REF_PROXY_ALIAS = "private-next-rsc-mod-ref-proxy";
    var RSC_ACTION_VALIDATE_ALIAS = "private-next-rsc-action-validate";
    var RSC_ACTION_PROXY_ALIAS = "private-next-rsc-server-reference";
    var RSC_CACHE_WRAPPER_ALIAS = "private-next-rsc-cache-wrapper";
    var RSC_DYNAMIC_IMPORT_WRAPPER_ALIAS = "private-next-rsc-track-dynamic-import";
    var RSC_ACTION_ENCRYPTION_ALIAS = "private-next-rsc-action-encryption";
    var RSC_ACTION_CLIENT_WRAPPER_ALIAS = "private-next-rsc-action-client-wrapper";
    var PUBLIC_DIR_MIDDLEWARE_CONFLICT = `You can not have a '_next' folder inside of your public folder. This conflicts with the internal '/_next' route. https://nextjs.org/docs/messages/public-next-folder-conflict`;
    var SSG_GET_INITIAL_PROPS_CONFLICT = `You can not use getInitialProps with getStaticProps. To use SSG, please remove your getInitialProps`;
    var SERVER_PROPS_GET_INIT_PROPS_CONFLICT = `You can not use getInitialProps with getServerSideProps. Please remove getInitialProps.`;
    var SERVER_PROPS_SSG_CONFLICT = `You can not use getStaticProps or getStaticPaths with getServerSideProps. To use SSG, please remove getServerSideProps`;
    var STATIC_STATUS_PAGE_GET_INITIAL_PROPS_ERROR = `can not have getInitialProps/getServerSideProps, https://nextjs.org/docs/messages/404-get-initial-props`;
    var SERVER_PROPS_EXPORT_ERROR = `pages with \`getServerSideProps\` can not be exported. See more info here: https://nextjs.org/docs/messages/gssp-export`;
    var GSP_NO_RETURNED_VALUE = "Your `getStaticProps` function did not return an object. Did you forget to add a `return`?";
    var GSSP_NO_RETURNED_VALUE = "Your `getServerSideProps` function did not return an object. Did you forget to add a `return`?";
    var UNSTABLE_REVALIDATE_RENAME_ERROR = "The `unstable_revalidate` property is available for general use.\nPlease use `revalidate` instead.";
    var GSSP_COMPONENT_MEMBER_ERROR = `can not be attached to a page's component and must be exported from the page. See more info here: https://nextjs.org/docs/messages/gssp-component-member`;
    var NON_STANDARD_NODE_ENV = `You are using a non-standard "NODE_ENV" value in your environment. This creates inconsistencies in the project and is strongly advised against. Read more: https://nextjs.org/docs/messages/non-standard-node-env`;
    var SSG_FALLBACK_EXPORT_ERROR = `Pages with \`fallback\` enabled in \`getStaticPaths\` can not be exported. See more info here: https://nextjs.org/docs/messages/ssg-fallback-true-export`;
    var ESLINT_DEFAULT_DIRS = [
      "app",
      "pages",
      "components",
      "lib",
      "src"
    ];
    var SERVER_RUNTIME = {
      edge: "edge",
      experimentalEdge: "experimental-edge",
      nodejs: "nodejs"
    };
    var WEBPACK_LAYERS_NAMES = {
      /**
      * The layer for the shared code between the client and server bundles.
      */
      shared: "shared",
      /**
      * The layer for server-only runtime and picking up `react-server` export conditions.
      * Including app router RSC pages and app router custom routes and metadata routes.
      */
      reactServerComponents: "rsc",
      /**
      * Server Side Rendering layer for app (ssr).
      */
      serverSideRendering: "ssr",
      /**
      * The browser client bundle layer for actions.
      */
      actionBrowser: "action-browser",
      /**
      * The Node.js bundle layer for the API routes.
      */
      apiNode: "api-node",
      /**
      * The Edge Lite bundle layer for the API routes.
      */
      apiEdge: "api-edge",
      /**
      * The layer for the middleware code.
      */
      middleware: "middleware",
      /**
      * The layer for the instrumentation hooks.
      */
      instrument: "instrument",
      /**
      * The layer for assets on the edge.
      */
      edgeAsset: "edge-asset",
      /**
      * The browser client bundle layer for App directory.
      */
      appPagesBrowser: "app-pages-browser",
      /**
      * The browser client bundle layer for Pages directory.
      */
      pagesDirBrowser: "pages-dir-browser",
      /**
      * The Edge Lite bundle layer for Pages directory.
      */
      pagesDirEdge: "pages-dir-edge",
      /**
      * The Node.js bundle layer for Pages directory.
      */
      pagesDirNode: "pages-dir-node"
    };
    var WEBPACK_LAYERS = {
      ...WEBPACK_LAYERS_NAMES,
      GROUP: {
        builtinReact: [
          WEBPACK_LAYERS_NAMES.reactServerComponents,
          WEBPACK_LAYERS_NAMES.actionBrowser
        ],
        serverOnly: [
          WEBPACK_LAYERS_NAMES.reactServerComponents,
          WEBPACK_LAYERS_NAMES.actionBrowser,
          WEBPACK_LAYERS_NAMES.instrument,
          WEBPACK_LAYERS_NAMES.middleware
        ],
        neutralTarget: [
          // pages api
          WEBPACK_LAYERS_NAMES.apiNode,
          WEBPACK_LAYERS_NAMES.apiEdge
        ],
        clientOnly: [
          WEBPACK_LAYERS_NAMES.serverSideRendering,
          WEBPACK_LAYERS_NAMES.appPagesBrowser
        ],
        bundled: [
          WEBPACK_LAYERS_NAMES.reactServerComponents,
          WEBPACK_LAYERS_NAMES.actionBrowser,
          WEBPACK_LAYERS_NAMES.serverSideRendering,
          WEBPACK_LAYERS_NAMES.appPagesBrowser,
          WEBPACK_LAYERS_NAMES.shared,
          WEBPACK_LAYERS_NAMES.instrument,
          WEBPACK_LAYERS_NAMES.middleware
        ],
        appPages: [
          // app router pages and layouts
          WEBPACK_LAYERS_NAMES.reactServerComponents,
          WEBPACK_LAYERS_NAMES.serverSideRendering,
          WEBPACK_LAYERS_NAMES.appPagesBrowser,
          WEBPACK_LAYERS_NAMES.actionBrowser
        ]
      }
    };
    var WEBPACK_RESOURCE_QUERIES = {
      edgeSSREntry: "__next_edge_ssr_entry__",
      metadata: "__next_metadata__",
      metadataRoute: "__next_metadata_route__",
      metadataImageMeta: "__next_metadata_image_meta__"
    };
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/escape-regexp.js
var require_escape_regexp = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/escape-regexp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "escapeStringRegexp", {
      enumerable: true,
      get: function() {
        return escapeStringRegexp;
      }
    });
    var reHasRegExp = /[|\\{}()[\]^$+*?.-]/;
    var reReplaceRegExp = /[|\\{}()[\]^$+*?.-]/g;
    function escapeStringRegexp(str) {
      if (reHasRegExp.test(str)) {
        return str.replace(reReplaceRegExp, "\\$&");
      }
      return str;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/get-dynamic-param.js
var require_get_dynamic_param = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/get-dynamic-param.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      PARAMETER_PATTERN: function() {
        return PARAMETER_PATTERN;
      },
      getDynamicParam: function() {
        return getDynamicParam;
      },
      parseMatchedParameter: function() {
        return parseMatchedParameter;
      },
      parseParameter: function() {
        return parseParameter;
      }
    });
    function getDynamicParam(params, segmentKey, dynamicParamType, pagePath, fallbackRouteParams) {
      let value = params[segmentKey];
      if (fallbackRouteParams && fallbackRouteParams.has(segmentKey)) {
        value = fallbackRouteParams.get(segmentKey);
      } else if (Array.isArray(value)) {
        value = value.map((i) => encodeURIComponent(i));
      } else if (typeof value === "string") {
        value = encodeURIComponent(value);
      }
      if (!value) {
        const isCatchall = dynamicParamType === "c";
        const isOptionalCatchall = dynamicParamType === "oc";
        if (isCatchall || isOptionalCatchall) {
          if (isOptionalCatchall) {
            return {
              param: segmentKey,
              value: null,
              type: dynamicParamType,
              treeSegment: [
                segmentKey,
                "",
                dynamicParamType
              ]
            };
          }
          value = pagePath.split("/").slice(1).flatMap((pathSegment) => {
            const param = parseParameter(pathSegment);
            var _params_param_key;
            return (_params_param_key = params[param.key]) != null ? _params_param_key : param.key;
          });
          return {
            param: segmentKey,
            value,
            type: dynamicParamType,
            // This value always has to be a string.
            treeSegment: [
              segmentKey,
              value.join("/"),
              dynamicParamType
            ]
          };
        }
      }
      return {
        param: segmentKey,
        // The value that is passed to user code.
        value,
        // The value that is rendered in the router tree.
        treeSegment: [
          segmentKey,
          Array.isArray(value) ? value.join("/") : value,
          dynamicParamType
        ],
        type: dynamicParamType
      };
    }
    var PARAMETER_PATTERN = /^([^[]*)\[((?:\[[^\]]*\])|[^\]]+)\](.*)$/;
    function parseParameter(param) {
      const match = param.match(PARAMETER_PATTERN);
      if (!match) {
        return parseMatchedParameter(param);
      }
      return parseMatchedParameter(match[2]);
    }
    function parseMatchedParameter(param) {
      const optional = param.startsWith("[") && param.endsWith("]");
      if (optional) {
        param = param.slice(1, -1);
      }
      const repeat = param.startsWith("...");
      if (repeat) {
        param = param.slice(3);
      }
      return {
        key: param,
        repeat,
        optional
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/route-regex.js
var require_route_regex = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/route-regex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      getNamedMiddlewareRegex: function() {
        return getNamedMiddlewareRegex;
      },
      getNamedRouteRegex: function() {
        return getNamedRouteRegex;
      },
      getRouteRegex: function() {
        return getRouteRegex;
      }
    });
    var _constants = require_constants();
    var _interceptionroutes = require_interception_routes();
    var _escaperegexp = require_escape_regexp();
    var _removetrailingslash = require_remove_trailing_slash();
    var _getdynamicparam = require_get_dynamic_param();
    function getParametrizedRoute(route, includeSuffix, includePrefix) {
      const groups = {};
      let groupIndex = 1;
      const segments = [];
      for (const segment of (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split("/")) {
        const markerMatch = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m));
        const paramMatches = segment.match(_getdynamicparam.PARAMETER_PATTERN);
        if (markerMatch && paramMatches && paramMatches[2]) {
          const { key, optional, repeat } = (0, _getdynamicparam.parseMatchedParameter)(paramMatches[2]);
          groups[key] = {
            pos: groupIndex++,
            repeat,
            optional
          };
          segments.push("/" + (0, _escaperegexp.escapeStringRegexp)(markerMatch) + "([^/]+?)");
        } else if (paramMatches && paramMatches[2]) {
          const { key, repeat, optional } = (0, _getdynamicparam.parseMatchedParameter)(paramMatches[2]);
          groups[key] = {
            pos: groupIndex++,
            repeat,
            optional
          };
          if (includePrefix && paramMatches[1]) {
            segments.push("/" + (0, _escaperegexp.escapeStringRegexp)(paramMatches[1]));
          }
          let s = repeat ? optional ? "(?:/(.+?))?" : "/(.+?)" : "/([^/]+?)";
          if (includePrefix && paramMatches[1]) {
            s = s.substring(1);
          }
          segments.push(s);
        } else {
          segments.push("/" + (0, _escaperegexp.escapeStringRegexp)(segment));
        }
        if (includeSuffix && paramMatches && paramMatches[3]) {
          segments.push((0, _escaperegexp.escapeStringRegexp)(paramMatches[3]));
        }
      }
      return {
        parameterizedRoute: segments.join(""),
        groups
      };
    }
    function getRouteRegex(normalizedRoute, param) {
      let { includeSuffix = false, includePrefix = false, excludeOptionalTrailingSlash = false } = param === void 0 ? {} : param;
      const { parameterizedRoute, groups } = getParametrizedRoute(normalizedRoute, includeSuffix, includePrefix);
      let re = parameterizedRoute;
      if (!excludeOptionalTrailingSlash) {
        re += "(?:/)?";
      }
      return {
        re: new RegExp("^" + re + "$"),
        groups
      };
    }
    function buildGetSafeRouteKey() {
      let i = 0;
      return () => {
        let routeKey = "";
        let j = ++i;
        while (j > 0) {
          routeKey += String.fromCharCode(97 + (j - 1) % 26);
          j = Math.floor((j - 1) / 26);
        }
        return routeKey;
      };
    }
    function getSafeKeyFromSegment(param) {
      let { interceptionMarker, getSafeRouteKey, segment, routeKeys, keyPrefix, backreferenceDuplicateKeys } = param;
      const { key, optional, repeat } = (0, _getdynamicparam.parseMatchedParameter)(segment);
      let cleanedKey = key.replace(/\W/g, "");
      if (keyPrefix) {
        cleanedKey = "" + keyPrefix + cleanedKey;
      }
      let invalidKey = false;
      if (cleanedKey.length === 0 || cleanedKey.length > 30) {
        invalidKey = true;
      }
      if (!isNaN(parseInt(cleanedKey.slice(0, 1)))) {
        invalidKey = true;
      }
      if (invalidKey) {
        cleanedKey = getSafeRouteKey();
      }
      const duplicateKey = cleanedKey in routeKeys;
      if (keyPrefix) {
        routeKeys[cleanedKey] = "" + keyPrefix + key;
      } else {
        routeKeys[cleanedKey] = key;
      }
      const interceptionPrefix = interceptionMarker ? (0, _escaperegexp.escapeStringRegexp)(interceptionMarker) : "";
      let pattern;
      if (duplicateKey && backreferenceDuplicateKeys) {
        pattern = "\\k<" + cleanedKey + ">";
      } else if (repeat) {
        pattern = "(?<" + cleanedKey + ">.+?)";
      } else {
        pattern = "(?<" + cleanedKey + ">[^/]+?)";
      }
      return optional ? "(?:/" + interceptionPrefix + pattern + ")?" : "/" + interceptionPrefix + pattern;
    }
    function getNamedParametrizedRoute(route, prefixRouteKeys, includeSuffix, includePrefix, backreferenceDuplicateKeys) {
      const getSafeRouteKey = buildGetSafeRouteKey();
      const routeKeys = {};
      const segments = [];
      for (const segment of (0, _removetrailingslash.removeTrailingSlash)(route).slice(1).split("/")) {
        const hasInterceptionMarker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.some((m) => segment.startsWith(m));
        const paramMatches = segment.match(_getdynamicparam.PARAMETER_PATTERN);
        if (hasInterceptionMarker && paramMatches && paramMatches[2]) {
          segments.push(getSafeKeyFromSegment({
            getSafeRouteKey,
            interceptionMarker: paramMatches[1],
            segment: paramMatches[2],
            routeKeys,
            keyPrefix: prefixRouteKeys ? _constants.NEXT_INTERCEPTION_MARKER_PREFIX : void 0,
            backreferenceDuplicateKeys
          }));
        } else if (paramMatches && paramMatches[2]) {
          if (includePrefix && paramMatches[1]) {
            segments.push("/" + (0, _escaperegexp.escapeStringRegexp)(paramMatches[1]));
          }
          let s = getSafeKeyFromSegment({
            getSafeRouteKey,
            segment: paramMatches[2],
            routeKeys,
            keyPrefix: prefixRouteKeys ? _constants.NEXT_QUERY_PARAM_PREFIX : void 0,
            backreferenceDuplicateKeys
          });
          if (includePrefix && paramMatches[1]) {
            s = s.substring(1);
          }
          segments.push(s);
        } else {
          segments.push("/" + (0, _escaperegexp.escapeStringRegexp)(segment));
        }
        if (includeSuffix && paramMatches && paramMatches[3]) {
          segments.push((0, _escaperegexp.escapeStringRegexp)(paramMatches[3]));
        }
      }
      return {
        namedParameterizedRoute: segments.join(""),
        routeKeys
      };
    }
    function getNamedRouteRegex(normalizedRoute, options) {
      var _options_includeSuffix, _options_includePrefix, _options_backreferenceDuplicateKeys;
      const result = getNamedParametrizedRoute(normalizedRoute, options.prefixRouteKeys, (_options_includeSuffix = options.includeSuffix) != null ? _options_includeSuffix : false, (_options_includePrefix = options.includePrefix) != null ? _options_includePrefix : false, (_options_backreferenceDuplicateKeys = options.backreferenceDuplicateKeys) != null ? _options_backreferenceDuplicateKeys : false);
      let namedRegex = result.namedParameterizedRoute;
      if (!options.excludeOptionalTrailingSlash) {
        namedRegex += "(?:/)?";
      }
      return {
        ...getRouteRegex(normalizedRoute, options),
        namedRegex: "^" + namedRegex + "$",
        routeKeys: result.routeKeys
      };
    }
    function getNamedMiddlewareRegex(normalizedRoute, options) {
      const { parameterizedRoute } = getParametrizedRoute(normalizedRoute, false, false);
      const { catchAll = true } = options;
      if (parameterizedRoute === "/") {
        let catchAllRegex = catchAll ? ".*" : "";
        return {
          namedRegex: "^/" + catchAllRegex + "$"
        };
      }
      const { namedParameterizedRoute } = getNamedParametrizedRoute(normalizedRoute, false, false, false, false);
      let catchAllGroupedRegex = catchAll ? "(?:(/.*)?)" : "";
      return {
        namedRegex: "^" + namedParameterizedRoute + catchAllGroupedRegex + "$"
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/format-url.js
var require_format_url = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/format-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      formatUrl: function() {
        return formatUrl;
      },
      formatWithValidation: function() {
        return formatWithValidation;
      },
      urlObjectKeys: function() {
        return urlObjectKeys;
      }
    });
    var _interop_require_wildcard = require_interop_require_wildcard();
    var _querystring = _interop_require_wildcard._(require_querystring());
    var slashedProtocols = /https?|ftp|gopher|file/;
    function formatUrl(urlObj) {
      let { auth, hostname } = urlObj;
      let protocol = urlObj.protocol || "";
      let pathname = urlObj.pathname || "";
      let hash = urlObj.hash || "";
      let query = urlObj.query || "";
      let host = false;
      auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ":") + "@" : "";
      if (urlObj.host) {
        host = auth + urlObj.host;
      } else if (hostname) {
        host = auth + (~hostname.indexOf(":") ? "[" + hostname + "]" : hostname);
        if (urlObj.port) {
          host += ":" + urlObj.port;
        }
      }
      if (query && typeof query === "object") {
        query = String(_querystring.urlQueryToSearchParams(query));
      }
      let search = urlObj.search || query && "?" + query || "";
      if (protocol && !protocol.endsWith(":")) protocol += ":";
      if (urlObj.slashes || (!protocol || slashedProtocols.test(protocol)) && host !== false) {
        host = "//" + (host || "");
        if (pathname && pathname[0] !== "/") pathname = "/" + pathname;
      } else if (!host) {
        host = "";
      }
      if (hash && hash[0] !== "#") hash = "#" + hash;
      if (search && search[0] !== "?") search = "?" + search;
      pathname = pathname.replace(/[?#]/g, encodeURIComponent);
      search = search.replace("#", "%23");
      return "" + protocol + host + pathname + search + hash;
    }
    var urlObjectKeys = [
      "auth",
      "hash",
      "host",
      "hostname",
      "href",
      "path",
      "pathname",
      "port",
      "protocol",
      "query",
      "search",
      "slashes"
    ];
    function formatWithValidation(url) {
      if (true) {
        if (url !== null && typeof url === "object") {
          Object.keys(url).forEach((key) => {
            if (!urlObjectKeys.includes(key)) {
              console.warn("Unknown key passed via urlObject into url.format: " + key);
            }
          });
        }
      }
      return formatUrl(url);
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js
var require_detect_domain_locale = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/i18n/detect-domain-locale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "detectDomainLocale", {
      enumerable: true,
      get: function() {
        return detectDomainLocale;
      }
    });
    function detectDomainLocale(domainItems, hostname, detectedLocale) {
      if (!domainItems) return;
      if (detectedLocale) {
        detectedLocale = detectedLocale.toLowerCase();
      }
      for (const item of domainItems) {
        var _item_domain, _item_locales;
        const domainHostname = (_item_domain = item.domain) == null ? void 0 : _item_domain.split(":", 1)[0].toLowerCase();
        if (hostname === domainHostname || detectedLocale === item.defaultLocale.toLowerCase() || ((_item_locales = item.locales) == null ? void 0 : _item_locales.some((locale) => locale.toLowerCase() === detectedLocale))) {
          return item;
        }
      }
    }
  }
});

// portfolio-site/node_modules/next/dist/client/detect-domain-locale.js
var require_detect_domain_locale2 = __commonJS({
  "portfolio-site/node_modules/next/dist/client/detect-domain-locale.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "detectDomainLocale", {
      enumerable: true,
      get: function() {
        return detectDomainLocale;
      }
    });
    var detectDomainLocale = function() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      if (process.env.__NEXT_I18N_SUPPORT) {
        return require_detect_domain_locale().detectDomainLocale(...args);
      }
    };
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/parse-path.js
var require_parse_path = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/parse-path.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "parsePath", {
      enumerable: true,
      get: function() {
        return parsePath;
      }
    });
    function parsePath(path) {
      const hashIndex = path.indexOf("#");
      const queryIndex = path.indexOf("?");
      const hasQuery = queryIndex > -1 && (hashIndex < 0 || queryIndex < hashIndex);
      if (hasQuery || hashIndex > -1) {
        return {
          pathname: path.substring(0, hasQuery ? queryIndex : hashIndex),
          query: hasQuery ? path.substring(queryIndex, hashIndex > -1 ? hashIndex : void 0) : "",
          hash: hashIndex > -1 ? path.slice(hashIndex) : ""
        };
      }
      return {
        pathname: path,
        query: "",
        hash: ""
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/client/normalize-trailing-slash.js
var require_normalize_trailing_slash = __commonJS({
  "portfolio-site/node_modules/next/dist/client/normalize-trailing-slash.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "normalizePathTrailingSlash", {
      enumerable: true,
      get: function() {
        return normalizePathTrailingSlash;
      }
    });
    var _removetrailingslash = require_remove_trailing_slash();
    var _parsepath = require_parse_path();
    var normalizePathTrailingSlash = (path) => {
      if (!path.startsWith("/") || process.env.__NEXT_MANUAL_TRAILING_SLASH) {
        return path;
      }
      const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
      if (process.env.__NEXT_TRAILING_SLASH) {
        if (/\.[^/]+\/?$/.test(pathname)) {
          return "" + (0, _removetrailingslash.removeTrailingSlash)(pathname) + query + hash;
        } else if (pathname.endsWith("/")) {
          return "" + pathname + query + hash;
        } else {
          return pathname + "/" + query + hash;
        }
      }
      return "" + (0, _removetrailingslash.removeTrailingSlash)(pathname) + query + hash;
    };
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js
var require_add_path_prefix = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/add-path-prefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "addPathPrefix", {
      enumerable: true,
      get: function() {
        return addPathPrefix;
      }
    });
    var _parsepath = require_parse_path();
    function addPathPrefix(path, prefix) {
      if (!path.startsWith("/") || !prefix) {
        return path;
      }
      const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
      return "" + prefix + pathname + query + hash;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js
var require_path_has_prefix = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/path-has-prefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "pathHasPrefix", {
      enumerable: true,
      get: function() {
        return pathHasPrefix;
      }
    });
    var _parsepath = require_parse_path();
    function pathHasPrefix(path, prefix) {
      if (typeof path !== "string") {
        return false;
      }
      const { pathname } = (0, _parsepath.parsePath)(path);
      return pathname === prefix || pathname.startsWith(prefix + "/");
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/add-locale.js
var require_add_locale = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/add-locale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "addLocale", {
      enumerable: true,
      get: function() {
        return addLocale;
      }
    });
    var _addpathprefix = require_add_path_prefix();
    var _pathhasprefix = require_path_has_prefix();
    function addLocale(path, locale, defaultLocale, ignorePrefix) {
      if (!locale || locale === defaultLocale) return path;
      const lower = path.toLowerCase();
      if (!ignorePrefix) {
        if ((0, _pathhasprefix.pathHasPrefix)(lower, "/api")) return path;
        if ((0, _pathhasprefix.pathHasPrefix)(lower, "/" + locale.toLowerCase())) return path;
      }
      return (0, _addpathprefix.addPathPrefix)(path, "/" + locale);
    }
  }
});

// portfolio-site/node_modules/next/dist/client/add-locale.js
var require_add_locale2 = __commonJS({
  "portfolio-site/node_modules/next/dist/client/add-locale.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "addLocale", {
      enumerable: true,
      get: function() {
        return addLocale;
      }
    });
    var _normalizetrailingslash = require_normalize_trailing_slash();
    var addLocale = function(path) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (process.env.__NEXT_I18N_SUPPORT) {
        return (0, _normalizetrailingslash.normalizePathTrailingSlash)(require_add_locale().addLocale(path, ...args));
      }
      return path;
    };
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/client/remove-locale.js
var require_remove_locale = __commonJS({
  "portfolio-site/node_modules/next/dist/client/remove-locale.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "removeLocale", {
      enumerable: true,
      get: function() {
        return removeLocale;
      }
    });
    var _parsepath = require_parse_path();
    function removeLocale(path, locale) {
      if (process.env.__NEXT_I18N_SUPPORT) {
        const { pathname } = (0, _parsepath.parsePath)(path);
        const pathLower = pathname.toLowerCase();
        const localeLower = locale == null ? void 0 : locale.toLowerCase();
        return locale && (pathLower.startsWith("/" + localeLower + "/") || pathLower === "/" + localeLower) ? (pathname.length === locale.length + 1 ? "/" : "") + path.slice(locale.length + 1) : path;
      }
      return path;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/client/has-base-path.js
var require_has_base_path = __commonJS({
  "portfolio-site/node_modules/next/dist/client/has-base-path.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "hasBasePath", {
      enumerable: true,
      get: function() {
        return hasBasePath;
      }
    });
    var _pathhasprefix = require_path_has_prefix();
    var basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
    function hasBasePath(path) {
      return (0, _pathhasprefix.pathHasPrefix)(path, basePath);
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/client/remove-base-path.js
var require_remove_base_path = __commonJS({
  "portfolio-site/node_modules/next/dist/client/remove-base-path.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "removeBasePath", {
      enumerable: true,
      get: function() {
        return removeBasePath;
      }
    });
    var _hasbasepath = require_has_base_path();
    var basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
    function removeBasePath(path) {
      if (process.env.__NEXT_MANUAL_CLIENT_BASE_PATH) {
        if (!(0, _hasbasepath.hasBasePath)(path)) {
          return path;
        }
      }
      if (basePath.length === 0) return path;
      path = path.slice(basePath.length);
      if (!path.startsWith("/")) path = "/" + path;
      return path;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/client/add-base-path.js
var require_add_base_path = __commonJS({
  "portfolio-site/node_modules/next/dist/client/add-base-path.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "addBasePath", {
      enumerable: true,
      get: function() {
        return addBasePath;
      }
    });
    var _addpathprefix = require_add_path_prefix();
    var _normalizetrailingslash = require_normalize_trailing_slash();
    var basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
    function addBasePath(path, required) {
      return (0, _normalizetrailingslash.normalizePathTrailingSlash)(process.env.__NEXT_MANUAL_CLIENT_BASE_PATH && !required ? path : (0, _addpathprefix.addPathPrefix)(path, basePath));
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/omit.js
var require_omit = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/omit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "omit", {
      enumerable: true,
      get: function() {
        return omit;
      }
    });
    function omit(object, keys) {
      const omitted = {};
      Object.keys(object).forEach((key) => {
        if (!keys.includes(key)) {
          omitted[key] = object[key];
        }
      });
      return omitted;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/is-local-url.js
var require_is_local_url = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/is-local-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isLocalURL", {
      enumerable: true,
      get: function() {
        return isLocalURL;
      }
    });
    var _utils = require_utils2();
    var _hasbasepath = require_has_base_path();
    function isLocalURL(url) {
      if (!(0, _utils.isAbsoluteUrl)(url)) return true;
      try {
        const locationOrigin = (0, _utils.getLocationOrigin)();
        const resolved = new URL(url, locationOrigin);
        return resolved.origin === locationOrigin && (0, _hasbasepath.hasBasePath)(resolved.pathname);
      } catch (_) {
        return false;
      }
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js
var require_interpolate_as = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/interpolate-as.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "interpolateAs", {
      enumerable: true,
      get: function() {
        return interpolateAs;
      }
    });
    var _routematcher = require_route_matcher();
    var _routeregex = require_route_regex();
    function interpolateAs(route, asPathname, query) {
      let interpolatedRoute = "";
      const dynamicRegex = (0, _routeregex.getRouteRegex)(route);
      const dynamicGroups = dynamicRegex.groups;
      const dynamicMatches = (
        // Try to match the dynamic route against the asPath
        (asPathname !== route ? (0, _routematcher.getRouteMatcher)(dynamicRegex)(asPathname) : "") || // Fall back to reading the values from the href
        // TODO: should this take priority; also need to change in the router.
        query
      );
      interpolatedRoute = route;
      const params = Object.keys(dynamicGroups);
      if (!params.every((param) => {
        let value = dynamicMatches[param] || "";
        const { repeat, optional } = dynamicGroups[param];
        let replaced = "[" + (repeat ? "..." : "") + param + "]";
        if (optional) {
          replaced = (!value ? "/" : "") + "[" + replaced + "]";
        }
        if (repeat && !Array.isArray(value)) value = [
          value
        ];
        return (optional || param in dynamicMatches) && // Interpolate group into data URL if present
        (interpolatedRoute = interpolatedRoute.replace(replaced, repeat ? value.map(
          // these values should be fully encoded instead of just
          // path delimiter escaped since they are being inserted
          // into the URL and we expect URL encoded segments
          // when parsing dynamic route params
          (segment) => encodeURIComponent(segment)
        ).join("/") : encodeURIComponent(value)) || "/");
      })) {
        interpolatedRoute = "";
      }
      return {
        params,
        result: interpolatedRoute
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/client/resolve-href.js
var require_resolve_href = __commonJS({
  "portfolio-site/node_modules/next/dist/client/resolve-href.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "resolveHref", {
      enumerable: true,
      get: function() {
        return resolveHref;
      }
    });
    var _querystring = require_querystring();
    var _formaturl = require_format_url();
    var _omit = require_omit();
    var _utils = require_utils2();
    var _normalizetrailingslash = require_normalize_trailing_slash();
    var _islocalurl = require_is_local_url();
    var _utils1 = require_utils();
    var _interpolateas = require_interpolate_as();
    var _routeregex = require_route_regex();
    var _routematcher = require_route_matcher();
    function resolveHref(router, href, resolveAs) {
      let base;
      let urlAsString = typeof href === "string" ? href : (0, _formaturl.formatWithValidation)(href);
      const urlProtoMatch = urlAsString.match(/^[a-z][a-z0-9+.-]*:\/\//i);
      const urlAsStringNoProto = urlProtoMatch ? urlAsString.slice(urlProtoMatch[0].length) : urlAsString;
      const urlParts = urlAsStringNoProto.split("?", 1);
      if ((urlParts[0] || "").match(/(\/\/|\\)/)) {
        console.error("Invalid href '" + urlAsString + "' passed to next/router in page: '" + router.pathname + "'. Repeated forward-slashes (//) or backslashes \\ are not valid in the href.");
        const normalizedUrl = (0, _utils.normalizeRepeatedSlashes)(urlAsStringNoProto);
        urlAsString = (urlProtoMatch ? urlProtoMatch[0] : "") + normalizedUrl;
      }
      if (!(0, _islocalurl.isLocalURL)(urlAsString)) {
        return resolveAs ? [
          urlAsString
        ] : urlAsString;
      }
      try {
        let baseBase = urlAsString.startsWith("#") ? router.asPath : router.pathname;
        if (urlAsString.startsWith("?")) {
          baseBase = router.asPath;
          if ((0, _utils1.isDynamicRoute)(router.pathname)) {
            baseBase = router.pathname;
            const routeRegex = (0, _routeregex.getRouteRegex)(router.pathname);
            const match = (0, _routematcher.getRouteMatcher)(routeRegex)(router.asPath);
            if (!match) {
              baseBase = router.asPath;
            }
          }
        }
        base = new URL(baseBase, "http://n");
      } catch (_) {
        base = new URL("/", "http://n");
      }
      try {
        const finalUrl = new URL(urlAsString, base);
        finalUrl.pathname = (0, _normalizetrailingslash.normalizePathTrailingSlash)(finalUrl.pathname);
        let interpolatedAs = "";
        if ((0, _utils1.isDynamicRoute)(finalUrl.pathname) && finalUrl.searchParams && resolveAs) {
          const query = (0, _querystring.searchParamsToUrlQuery)(finalUrl.searchParams);
          const { result, params } = (0, _interpolateas.interpolateAs)(finalUrl.pathname, finalUrl.pathname, query);
          if (result) {
            interpolatedAs = (0, _formaturl.formatWithValidation)({
              pathname: result,
              hash: finalUrl.hash,
              query: (0, _omit.omit)(query, params)
            });
          }
        }
        const resolvedHref = finalUrl.origin === base.origin ? finalUrl.href.slice(finalUrl.origin.length) : finalUrl.href;
        return resolveAs ? [
          resolvedHref,
          interpolatedAs || resolvedHref
        ] : resolvedHref;
      } catch (_) {
        return resolveAs ? [
          urlAsString
        ] : urlAsString;
      }
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/lib/is-api-route.js
var require_is_api_route = __commonJS({
  "portfolio-site/node_modules/next/dist/lib/is-api-route.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "isAPIRoute", {
      enumerable: true,
      get: function() {
        return isAPIRoute;
      }
    });
    function isAPIRoute(value) {
      return value === "/api" || Boolean(value == null ? void 0 : value.startsWith("/api/"));
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js
var require_remove_path_prefix = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/remove-path-prefix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "removePathPrefix", {
      enumerable: true,
      get: function() {
        return removePathPrefix;
      }
    });
    var _pathhasprefix = require_path_has_prefix();
    function removePathPrefix(path, prefix) {
      if (!(0, _pathhasprefix.pathHasPrefix)(path, prefix)) {
        return path;
      }
      const withoutPrefix = path.slice(prefix.length);
      if (withoutPrefix.startsWith("/")) {
        return withoutPrefix;
      }
      return "/" + withoutPrefix;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js
var require_get_next_pathname_info = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getNextPathnameInfo", {
      enumerable: true,
      get: function() {
        return getNextPathnameInfo;
      }
    });
    var _normalizelocalepath = require_normalize_locale_path();
    var _removepathprefix = require_remove_path_prefix();
    var _pathhasprefix = require_path_has_prefix();
    function getNextPathnameInfo(pathname, options) {
      var _options_nextConfig;
      const { basePath, i18n, trailingSlash } = (_options_nextConfig = options.nextConfig) != null ? _options_nextConfig : {};
      const info = {
        pathname,
        trailingSlash: pathname !== "/" ? pathname.endsWith("/") : trailingSlash
      };
      if (basePath && (0, _pathhasprefix.pathHasPrefix)(info.pathname, basePath)) {
        info.pathname = (0, _removepathprefix.removePathPrefix)(info.pathname, basePath);
        info.basePath = basePath;
      }
      let pathnameNoDataPrefix = info.pathname;
      if (info.pathname.startsWith("/_next/data/") && info.pathname.endsWith(".json")) {
        const paths = info.pathname.replace(/^\/_next\/data\//, "").replace(/\.json$/, "").split("/");
        const buildId = paths[0];
        info.buildId = buildId;
        pathnameNoDataPrefix = paths[1] !== "index" ? "/" + paths.slice(1).join("/") : "/";
        if (options.parseData === true) {
          info.pathname = pathnameNoDataPrefix;
        }
      }
      if (i18n) {
        let result = options.i18nProvider ? options.i18nProvider.analyze(info.pathname) : (0, _normalizelocalepath.normalizeLocalePath)(info.pathname, i18n.locales);
        info.locale = result.detectedLocale;
        var _result_pathname;
        info.pathname = (_result_pathname = result.pathname) != null ? _result_pathname : info.pathname;
        if (!result.detectedLocale && info.buildId) {
          result = options.i18nProvider ? options.i18nProvider.analyze(pathnameNoDataPrefix) : (0, _normalizelocalepath.normalizeLocalePath)(pathnameNoDataPrefix, i18n.locales);
          if (result.detectedLocale) {
            info.locale = result.detectedLocale;
          }
        }
      }
      return info;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js
var require_add_path_suffix = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/add-path-suffix.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "addPathSuffix", {
      enumerable: true,
      get: function() {
        return addPathSuffix;
      }
    });
    var _parsepath = require_parse_path();
    function addPathSuffix(path, suffix) {
      if (!path.startsWith("/") || !suffix) {
        return path;
      }
      const { pathname, query, hash } = (0, _parsepath.parsePath)(path);
      return "" + pathname + suffix + query + hash;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js
var require_format_next_pathname_info = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "formatNextPathnameInfo", {
      enumerable: true,
      get: function() {
        return formatNextPathnameInfo;
      }
    });
    var _removetrailingslash = require_remove_trailing_slash();
    var _addpathprefix = require_add_path_prefix();
    var _addpathsuffix = require_add_path_suffix();
    var _addlocale = require_add_locale();
    function formatNextPathnameInfo(info) {
      let pathname = (0, _addlocale.addLocale)(info.pathname, info.locale, info.buildId ? void 0 : info.defaultLocale, info.ignorePrefix);
      if (info.buildId || !info.trailingSlash) {
        pathname = (0, _removetrailingslash.removeTrailingSlash)(pathname);
      }
      if (info.buildId) {
        pathname = (0, _addpathsuffix.addPathSuffix)((0, _addpathprefix.addPathPrefix)(pathname, "/_next/data/" + info.buildId), info.pathname === "/" ? "index.json" : ".json");
      }
      pathname = (0, _addpathprefix.addPathPrefix)(pathname, info.basePath);
      return !info.buildId && info.trailingSlash ? !pathname.endsWith("/") ? (0, _addpathsuffix.addPathSuffix)(pathname, "/") : pathname : (0, _removetrailingslash.removeTrailingSlash)(pathname);
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/compare-states.js
var require_compare_states = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/compare-states.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "compareRouterStates", {
      enumerable: true,
      get: function() {
        return compareRouterStates;
      }
    });
    function compareRouterStates(a, b) {
      const stateKeys = Object.keys(a);
      if (stateKeys.length !== Object.keys(b).length) return false;
      for (let i = stateKeys.length; i--; ) {
        const key = stateKeys[i];
        if (key === "query") {
          const queryKeys = Object.keys(a.query);
          if (queryKeys.length !== Object.keys(b.query).length) {
            return false;
          }
          for (let j = queryKeys.length; j--; ) {
            const queryKey = queryKeys[j];
            if (!b.query.hasOwnProperty(queryKey) || a.query[queryKey] !== b.query[queryKey]) {
              return false;
            }
          }
        } else if (!b.hasOwnProperty(key) || a[key] !== b[key]) {
          return false;
        }
      }
      return true;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/html-bots.js
var require_html_bots = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/html-bots.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "HTML_LIMITED_BOT_UA_RE", {
      enumerable: true,
      get: function() {
        return HTML_LIMITED_BOT_UA_RE;
      }
    });
    var HTML_LIMITED_BOT_UA_RE = /[\w-]+-Google|Google-[\w-]+|Chrome-Lighthouse|Slurp|DuckDuckBot|baiduspider|yandex|sogou|bitlybot|tumblr|vkShare|quora link preview|redditbot|ia_archiver|Bingbot|BingPreview|applebot|facebookexternalhit|facebookcatalog|Twitterbot|LinkedInBot|Slackbot|Discordbot|WhatsApp|SkypeUriPreview|Yeti|googleweblight/i;
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/is-bot.js
var require_is_bot = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/is-bot.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      HTML_LIMITED_BOT_UA_RE: function() {
        return _htmlbots.HTML_LIMITED_BOT_UA_RE;
      },
      HTML_LIMITED_BOT_UA_RE_STRING: function() {
        return HTML_LIMITED_BOT_UA_RE_STRING;
      },
      getBotType: function() {
        return getBotType;
      },
      isBot: function() {
        return isBot;
      }
    });
    var _htmlbots = require_html_bots();
    var HEADLESS_BROWSER_BOT_UA_RE = /Googlebot(?!-)|Googlebot$/i;
    var HTML_LIMITED_BOT_UA_RE_STRING = _htmlbots.HTML_LIMITED_BOT_UA_RE.source;
    function isDomBotUA(userAgent) {
      return HEADLESS_BROWSER_BOT_UA_RE.test(userAgent);
    }
    function isHtmlLimitedBotUA(userAgent) {
      return _htmlbots.HTML_LIMITED_BOT_UA_RE.test(userAgent);
    }
    function isBot(userAgent) {
      return isDomBotUA(userAgent) || isHtmlLimitedBotUA(userAgent);
    }
    function getBotType(userAgent) {
      if (isDomBotUA(userAgent)) {
        return "dom";
      }
      if (isHtmlLimitedBotUA(userAgent)) {
        return "html";
      }
      return void 0;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/utils/warn-once.js
var require_warn_once = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/utils/warn-once.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "warnOnce", {
      enumerable: true,
      get: function() {
        return warnOnce;
      }
    });
    var warnOnce = (_) => {
    };
    if (true) {
      const warnings = /* @__PURE__ */ new Set();
      warnOnce = (msg) => {
        if (!warnings.has(msg)) {
          console.warn(msg);
        }
        warnings.add(msg);
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js
var require_disable_smooth_scroll = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/disable-smooth-scroll.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "disableSmoothScrollDuringRouteTransition", {
      enumerable: true,
      get: function() {
        return disableSmoothScrollDuringRouteTransition;
      }
    });
    var _warnonce = require_warn_once();
    function disableSmoothScrollDuringRouteTransition(fn, options) {
      if (options === void 0) options = {};
      if (options.onlyHashChange) {
        fn();
        return;
      }
      const htmlElement = document.documentElement;
      const hasDataAttribute = htmlElement.dataset.scrollBehavior === "smooth";
      if (process.env.__NEXT_OPTIMIZE_ROUTER_SCROLL) {
        if (!hasDataAttribute) {
          fn();
          return;
        }
      } else {
        if (!hasDataAttribute && getComputedStyle(htmlElement).scrollBehavior === "smooth") {
          (0, _warnonce.warnOnce)('Detected `scroll-behavior: smooth` on the `<html>` element. In a future version, Next.js will no longer automatically disable smooth scrolling during route transitions. To prepare for this change, add `data-scroll-behavior="smooth"` to your <html> element. Learn more: https://nextjs.org/docs/messages/missing-data-scroll-behavior');
        }
      }
      const existing = htmlElement.style.scrollBehavior;
      htmlElement.style.scrollBehavior = "auto";
      if (!options.dontForceLayout) {
        htmlElement.getClientRects();
      }
      fn();
      htmlElement.style.scrollBehavior = existing;
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/path-match.js
var require_path_match = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/path-match.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getPathMatch", {
      enumerable: true,
      get: function() {
        return getPathMatch;
      }
    });
    var _pathtoregexp = require_path_to_regexp();
    function getPathMatch(path, options) {
      const keys = [];
      const regexp = (0, _pathtoregexp.pathToRegexp)(path, keys, {
        delimiter: "/",
        sensitive: typeof (options == null ? void 0 : options.sensitive) === "boolean" ? options.sensitive : false,
        strict: options == null ? void 0 : options.strict
      });
      const matcher = (0, _pathtoregexp.regexpToFunction)((options == null ? void 0 : options.regexModifier) ? new RegExp(options.regexModifier(regexp.source), regexp.flags) : regexp, keys);
      return (pathname, params) => {
        if (typeof pathname !== "string") return false;
        const match = matcher(pathname);
        if (!match) return false;
        if (options == null ? void 0 : options.removeUnnamedParams) {
          for (const key of keys) {
            if (typeof key.name === "number") {
              delete match.params[key.name];
            }
          }
        }
        return {
          ...params,
          ...match.params
        };
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/parse-url.js
var require_parse_url = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/parse-url.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "parseUrl", {
      enumerable: true,
      get: function() {
        return parseUrl;
      }
    });
    var _querystring = require_querystring();
    var _parserelativeurl = require_parse_relative_url();
    function parseUrl(url) {
      if (url.startsWith("/")) {
        return (0, _parserelativeurl.parseRelativeUrl)(url);
      }
      const parsedURL = new URL(url);
      return {
        hash: parsedURL.hash,
        hostname: parsedURL.hostname,
        href: parsedURL.href,
        pathname: parsedURL.pathname,
        port: parsedURL.port,
        protocol: parsedURL.protocol,
        query: (0, _querystring.searchParamsToUrlQuery)(parsedURL.searchParams),
        search: parsedURL.search,
        slashes: parsedURL.href.slice(parsedURL.protocol.length, parsedURL.protocol.length + 2) === "//"
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/compiled/cookie/index.js
var require_cookie = __commonJS({
  "portfolio-site/node_modules/next/dist/compiled/cookie/index.js"(exports, module) {
    (() => {
      "use strict";
      if (typeof __nccwpck_require__ !== "undefined") __nccwpck_require__.ab = __dirname + "/";
      var e = {};
      (() => {
        var r = e;
        r.parse = parse;
        r.serialize = serialize;
        var i = decodeURIComponent;
        var t = encodeURIComponent;
        var a = /; */;
        var n = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
        function parse(e2, r2) {
          if (typeof e2 !== "string") {
            throw new TypeError("argument str must be a string");
          }
          var t2 = {};
          var n2 = r2 || {};
          var o = e2.split(a);
          var s = n2.decode || i;
          for (var p = 0; p < o.length; p++) {
            var f = o[p];
            var u = f.indexOf("=");
            if (u < 0) {
              continue;
            }
            var v = f.substr(0, u).trim();
            var c = f.substr(++u, f.length).trim();
            if ('"' == c[0]) {
              c = c.slice(1, -1);
            }
            if (void 0 == t2[v]) {
              t2[v] = tryDecode(c, s);
            }
          }
          return t2;
        }
        function serialize(e2, r2, i2) {
          var a2 = i2 || {};
          var o = a2.encode || t;
          if (typeof o !== "function") {
            throw new TypeError("option encode is invalid");
          }
          if (!n.test(e2)) {
            throw new TypeError("argument name is invalid");
          }
          var s = o(r2);
          if (s && !n.test(s)) {
            throw new TypeError("argument val is invalid");
          }
          var p = e2 + "=" + s;
          if (null != a2.maxAge) {
            var f = a2.maxAge - 0;
            if (isNaN(f) || !isFinite(f)) {
              throw new TypeError("option maxAge is invalid");
            }
            p += "; Max-Age=" + Math.floor(f);
          }
          if (a2.domain) {
            if (!n.test(a2.domain)) {
              throw new TypeError("option domain is invalid");
            }
            p += "; Domain=" + a2.domain;
          }
          if (a2.path) {
            if (!n.test(a2.path)) {
              throw new TypeError("option path is invalid");
            }
            p += "; Path=" + a2.path;
          }
          if (a2.expires) {
            if (typeof a2.expires.toUTCString !== "function") {
              throw new TypeError("option expires is invalid");
            }
            p += "; Expires=" + a2.expires.toUTCString();
          }
          if (a2.httpOnly) {
            p += "; HttpOnly";
          }
          if (a2.secure) {
            p += "; Secure";
          }
          if (a2.sameSite) {
            var u = typeof a2.sameSite === "string" ? a2.sameSite.toLowerCase() : a2.sameSite;
            switch (u) {
              case true:
                p += "; SameSite=Strict";
                break;
              case "lax":
                p += "; SameSite=Lax";
                break;
              case "strict":
                p += "; SameSite=Strict";
                break;
              case "none":
                p += "; SameSite=None";
                break;
              default:
                throw new TypeError("option sameSite is invalid");
            }
          }
          return p;
        }
        function tryDecode(e2, r2) {
          try {
            return r2(e2);
          } catch (r3) {
            return e2;
          }
        }
      })();
      module.exports = e;
    })();
  }
});

// portfolio-site/node_modules/next/dist/server/api-utils/get-cookie-parser.js
var require_get_cookie_parser = __commonJS({
  "portfolio-site/node_modules/next/dist/server/api-utils/get-cookie-parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "getCookieParser", {
      enumerable: true,
      get: function() {
        return getCookieParser;
      }
    });
    function getCookieParser(headers) {
      return function parseCookie() {
        const { cookie } = headers;
        if (!cookie) {
          return {};
        }
        const { parse: parseCookieFn } = require_cookie();
        return parseCookieFn(Array.isArray(cookie) ? cookie.join("; ") : cookie);
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/prepare-destination.js
var require_prepare_destination = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/prepare-destination.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      compileNonPath: function() {
        return compileNonPath;
      },
      matchHas: function() {
        return matchHas;
      },
      parseDestination: function() {
        return parseDestination;
      },
      prepareDestination: function() {
        return prepareDestination;
      }
    });
    var _escaperegexp = require_escape_regexp();
    var _parseurl = require_parse_url();
    var _interceptionroutes = require_interception_routes();
    var _getcookieparser = require_get_cookie_parser();
    var _routematchutils = require_route_match_utils();
    function getSafeParamName(paramName) {
      let newParamName = "";
      for (let i = 0; i < paramName.length; i++) {
        const charCode = paramName.charCodeAt(i);
        if (charCode > 64 && charCode < 91 || // A-Z
        charCode > 96 && charCode < 123) {
          newParamName += paramName[i];
        }
      }
      return newParamName;
    }
    function escapeSegment(str, segmentName) {
      return str.replace(new RegExp(":" + (0, _escaperegexp.escapeStringRegexp)(segmentName), "g"), "__ESC_COLON_" + segmentName);
    }
    function unescapeSegments(str) {
      return str.replace(/__ESC_COLON_/gi, ":");
    }
    function matchHas(req, query, has, missing) {
      if (has === void 0) has = [];
      if (missing === void 0) missing = [];
      const params = {};
      const hasMatch = (hasItem) => {
        let value;
        let key = hasItem.key;
        switch (hasItem.type) {
          case "header": {
            key = key.toLowerCase();
            value = req.headers[key];
            break;
          }
          case "cookie": {
            if ("cookies" in req) {
              value = req.cookies[hasItem.key];
            } else {
              const cookies = (0, _getcookieparser.getCookieParser)(req.headers)();
              value = cookies[hasItem.key];
            }
            break;
          }
          case "query": {
            value = query[key];
            break;
          }
          case "host": {
            const { host } = (req == null ? void 0 : req.headers) || {};
            const hostname = host == null ? void 0 : host.split(":", 1)[0].toLowerCase();
            value = hostname;
            break;
          }
          default: {
            break;
          }
        }
        if (!hasItem.value && value) {
          params[getSafeParamName(key)] = value;
          return true;
        } else if (value) {
          const matcher = new RegExp("^" + hasItem.value + "$");
          const matches = Array.isArray(value) ? value.slice(-1)[0].match(matcher) : value.match(matcher);
          if (matches) {
            if (Array.isArray(matches)) {
              if (matches.groups) {
                Object.keys(matches.groups).forEach((groupKey) => {
                  params[groupKey] = matches.groups[groupKey];
                });
              } else if (hasItem.type === "host" && matches[0]) {
                params.host = matches[0];
              }
            }
            return true;
          }
        }
        return false;
      };
      const allMatch = has.every((item) => hasMatch(item)) && !missing.some((item) => hasMatch(item));
      if (allMatch) {
        return params;
      }
      return false;
    }
    function compileNonPath(value, params) {
      if (!value.includes(":")) {
        return value;
      }
      for (const key of Object.keys(params)) {
        if (value.includes(":" + key)) {
          value = value.replace(new RegExp(":" + key + "\\*", "g"), ":" + key + "--ESCAPED_PARAM_ASTERISKS").replace(new RegExp(":" + key + "\\?", "g"), ":" + key + "--ESCAPED_PARAM_QUESTION").replace(new RegExp(":" + key + "\\+", "g"), ":" + key + "--ESCAPED_PARAM_PLUS").replace(new RegExp(":" + key + "(?!\\w)", "g"), "--ESCAPED_PARAM_COLON" + key);
        }
      }
      value = value.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g, "\\$1").replace(/--ESCAPED_PARAM_PLUS/g, "+").replace(/--ESCAPED_PARAM_COLON/g, ":").replace(/--ESCAPED_PARAM_QUESTION/g, "?").replace(/--ESCAPED_PARAM_ASTERISKS/g, "*");
      return (0, _routematchutils.safeCompile)("/" + value, {
        validate: false
      })(params).slice(1);
    }
    function parseDestination(args) {
      let escaped = args.destination;
      for (const param of Object.keys({
        ...args.params,
        ...args.query
      })) {
        if (!param) continue;
        escaped = escapeSegment(escaped, param);
      }
      const parsed = (0, _parseurl.parseUrl)(escaped);
      let pathname = parsed.pathname;
      if (pathname) {
        pathname = unescapeSegments(pathname);
      }
      let href = parsed.href;
      if (href) {
        href = unescapeSegments(href);
      }
      let hostname = parsed.hostname;
      if (hostname) {
        hostname = unescapeSegments(hostname);
      }
      let hash = parsed.hash;
      if (hash) {
        hash = unescapeSegments(hash);
      }
      let search = parsed.search;
      if (search) {
        search = unescapeSegments(search);
      }
      return {
        ...parsed,
        pathname,
        hostname,
        href,
        hash,
        search
      };
    }
    function prepareDestination(args) {
      const parsedDestination = parseDestination(args);
      const { hostname: destHostname, query: destQuery, search: destSearch } = parsedDestination;
      let destPath = parsedDestination.pathname;
      if (parsedDestination.hash) {
        destPath = "" + destPath + parsedDestination.hash;
      }
      const destParams = [];
      const destPathParamKeys = [];
      (0, _routematchutils.safePathToRegexp)(destPath, destPathParamKeys);
      for (const key of destPathParamKeys) {
        destParams.push(key.name);
      }
      if (destHostname) {
        const destHostnameParamKeys = [];
        (0, _routematchutils.safePathToRegexp)(destHostname, destHostnameParamKeys);
        for (const key of destHostnameParamKeys) {
          destParams.push(key.name);
        }
      }
      const destPathCompiler = (0, _routematchutils.safeCompile)(
        destPath,
        // we don't validate while compiling the destination since we should
        // have already validated before we got to this point and validating
        // breaks compiling destinations with named pattern params from the source
        // e.g. /something:hello(.*) -> /another/:hello is broken with validation
        // since compile validation is meant for reversing and not for inserting
        // params from a separate path-regex into another
        {
          validate: false
        }
      );
      let destHostnameCompiler;
      if (destHostname) {
        destHostnameCompiler = (0, _routematchutils.safeCompile)(destHostname, {
          validate: false
        });
      }
      for (const [key, strOrArray] of Object.entries(destQuery)) {
        if (Array.isArray(strOrArray)) {
          destQuery[key] = strOrArray.map((value) => compileNonPath(unescapeSegments(value), args.params));
        } else if (typeof strOrArray === "string") {
          destQuery[key] = compileNonPath(unescapeSegments(strOrArray), args.params);
        }
      }
      let paramKeys = Object.keys(args.params).filter((name) => name !== "nextInternalLocale");
      if (args.appendParamsToQuery && !paramKeys.some((key) => destParams.includes(key))) {
        for (const key of paramKeys) {
          if (!(key in destQuery)) {
            destQuery[key] = args.params[key];
          }
        }
      }
      let newUrl;
      if ((0, _interceptionroutes.isInterceptionRouteAppPath)(destPath)) {
        for (const segment of destPath.split("/")) {
          const marker = _interceptionroutes.INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m));
          if (marker) {
            if (marker === "(..)(..)") {
              args.params["0"] = "(..)";
              args.params["1"] = "(..)";
            } else {
              args.params["0"] = marker;
            }
            break;
          }
        }
      }
      try {
        newUrl = destPathCompiler(args.params);
        const [pathname, hash] = newUrl.split("#", 2);
        if (destHostnameCompiler) {
          parsedDestination.hostname = destHostnameCompiler(args.params);
        }
        parsedDestination.pathname = pathname;
        parsedDestination.hash = (hash ? "#" : "") + (hash || "");
        parsedDestination.search = destSearch ? compileNonPath(destSearch, args.params) : "";
      } catch (err) {
        if (err.message.match(/Expected .*? to not repeat, but got an array/)) {
          throw Object.defineProperty(new Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match"), "__NEXT_ERROR_CODE", {
            value: "E329",
            enumerable: false,
            configurable: true
          });
        }
        throw err;
      }
      parsedDestination.query = {
        ...args.query,
        ...parsedDestination.query
      };
      return {
        newUrl,
        destQuery,
        parsedDestination
      };
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js
var require_resolve_rewrites = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/utils/resolve-rewrites.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return resolveRewrites;
      }
    });
    var _pathmatch = require_path_match();
    var _preparedestination = require_prepare_destination();
    var _removetrailingslash = require_remove_trailing_slash();
    var _normalizelocalepath = require_normalize_locale_path();
    var _removebasepath = require_remove_base_path();
    var _parserelativeurl = require_parse_relative_url();
    function resolveRewrites(asPath, pages, rewrites, query, resolveHref, locales) {
      let matchedPage = false;
      let externalDest = false;
      let parsedAs = (0, _parserelativeurl.parseRelativeUrl)(asPath);
      let fsPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedAs.pathname), locales).pathname);
      let resolvedHref;
      const handleRewrite = (rewrite) => {
        const matcher = (0, _pathmatch.getPathMatch)(rewrite.source + (process.env.__NEXT_TRAILING_SLASH ? "(/)?" : ""), {
          removeUnnamedParams: true,
          strict: true
        });
        let params = matcher(parsedAs.pathname);
        if ((rewrite.has || rewrite.missing) && params) {
          const hasParams = (0, _preparedestination.matchHas)({
            headers: {
              host: document.location.hostname,
              "user-agent": navigator.userAgent
            },
            cookies: document.cookie.split("; ").reduce((acc, item) => {
              const [key, ...value] = item.split("=");
              acc[key] = value.join("=");
              return acc;
            }, {})
          }, parsedAs.query, rewrite.has, rewrite.missing);
          if (hasParams) {
            Object.assign(params, hasParams);
          } else {
            params = false;
          }
        }
        if (params) {
          if (!rewrite.destination) {
            externalDest = true;
            return true;
          }
          const destRes = (0, _preparedestination.prepareDestination)({
            appendParamsToQuery: true,
            destination: rewrite.destination,
            params,
            query
          });
          parsedAs = destRes.parsedDestination;
          asPath = destRes.newUrl;
          Object.assign(query, destRes.parsedDestination.query);
          fsPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(asPath), locales).pathname);
          if (pages.includes(fsPathname)) {
            matchedPage = true;
            resolvedHref = fsPathname;
            return true;
          }
          resolvedHref = resolveHref(fsPathname);
          if (resolvedHref !== asPath && pages.includes(resolvedHref)) {
            matchedPage = true;
            return true;
          }
        }
      };
      let finished = false;
      for (let i = 0; i < rewrites.beforeFiles.length; i++) {
        handleRewrite(rewrites.beforeFiles[i]);
      }
      matchedPage = pages.includes(fsPathname);
      if (!matchedPage) {
        if (!finished) {
          for (let i = 0; i < rewrites.afterFiles.length; i++) {
            if (handleRewrite(rewrites.afterFiles[i])) {
              finished = true;
              break;
            }
          }
        }
        if (!finished) {
          resolvedHref = resolveHref(fsPathname);
          matchedPage = pages.includes(resolvedHref);
          finished = matchedPage;
        }
        if (!finished) {
          for (let i = 0; i < rewrites.fallback.length; i++) {
            if (handleRewrite(rewrites.fallback[i])) {
              finished = true;
              break;
            }
          }
        }
      }
      return {
        asPath,
        parsedAs,
        matchedPage,
        resolvedHref,
        externalDest
      };
    }
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// portfolio-site/node_modules/next/dist/compiled/gzip-size/index.js
var require_gzip_size = __commonJS({
  "portfolio-site/node_modules/next/dist/compiled/gzip-size/index.js"(exports, module) {
    (() => {
      var e = { 154: (e2, r2, t2) => {
        var n = t2(781);
        var o = ["write", "end", "destroy"];
        var i = ["resume", "pause"];
        var s = ["data", "close"];
        var c = Array.prototype.slice;
        e2.exports = duplex;
        function forEach(e3, r3) {
          if (e3.forEach) {
            return e3.forEach(r3);
          }
          for (var t3 = 0; t3 < e3.length; t3++) {
            r3(e3[t3], t3);
          }
        }
        function duplex(e3, r3) {
          var t3 = new n();
          var a = false;
          forEach(o, proxyWriter);
          forEach(i, proxyReader);
          forEach(s, proxyStream);
          r3.on("end", handleEnd);
          e3.on("drain", (function() {
            t3.emit("drain");
          }));
          e3.on("error", reemit);
          r3.on("error", reemit);
          t3.writable = e3.writable;
          t3.readable = r3.readable;
          return t3;
          function proxyWriter(r4) {
            t3[r4] = method;
            function method() {
              return e3[r4].apply(e3, arguments);
            }
          }
          function proxyReader(e4) {
            t3[e4] = method;
            function method() {
              t3.emit(e4);
              var n2 = r3[e4];
              if (n2) {
                return n2.apply(r3, arguments);
              }
              r3.emit(e4);
            }
          }
          function proxyStream(e4) {
            r3.on(e4, reemit2);
            function reemit2() {
              var r4 = c.call(arguments);
              r4.unshift(e4);
              t3.emit.apply(t3, r4);
            }
          }
          function handleEnd() {
            if (a) {
              return;
            }
            a = true;
            var e4 = c.call(arguments);
            e4.unshift("end");
            t3.emit.apply(t3, e4);
          }
          function reemit(e4) {
            t3.emit("error", e4);
          }
        }
      }, 349: (e2, r2, t2) => {
        "use strict";
        const n = t2(147);
        const o = t2(781);
        const i = t2(796);
        const s = t2(154);
        const c = t2(530);
        const getOptions = (e3) => Object.assign({ level: 9 }, e3);
        e2.exports = (e3, r3) => {
          if (!e3) {
            return Promise.resolve(0);
          }
          return c(i.gzip)(e3, getOptions(r3)).then(((e4) => e4.length)).catch(((e4) => 0));
        };
        e2.exports.sync = (e3, r3) => i.gzipSync(e3, getOptions(r3)).length;
        e2.exports.stream = (e3) => {
          const r3 = new o.PassThrough();
          const t3 = new o.PassThrough();
          const n2 = s(r3, t3);
          let c2 = 0;
          const a = i.createGzip(getOptions(e3)).on("data", ((e4) => {
            c2 += e4.length;
          })).on("error", (() => {
            n2.gzipSize = 0;
          })).on("end", (() => {
            n2.gzipSize = c2;
            n2.emit("gzip-size", c2);
            t3.end();
          }));
          r3.pipe(a);
          r3.pipe(t3, { end: false });
          return n2;
        };
        e2.exports.file = (r3, t3) => new Promise(((o2, i2) => {
          const s2 = n.createReadStream(r3);
          s2.on("error", i2);
          const c2 = s2.pipe(e2.exports.stream(t3));
          c2.on("error", i2);
          c2.on("gzip-size", o2);
        }));
        e2.exports.fileSync = (r3, t3) => e2.exports.sync(n.readFileSync(r3), t3);
      }, 530: (e2) => {
        "use strict";
        const processFn = (e3, r2) => function(...t2) {
          const n = r2.promiseModule;
          return new n(((n2, o) => {
            if (r2.multiArgs) {
              t2.push(((...e4) => {
                if (r2.errorFirst) {
                  if (e4[0]) {
                    o(e4);
                  } else {
                    e4.shift();
                    n2(e4);
                  }
                } else {
                  n2(e4);
                }
              }));
            } else if (r2.errorFirst) {
              t2.push(((e4, r3) => {
                if (e4) {
                  o(e4);
                } else {
                  n2(r3);
                }
              }));
            } else {
              t2.push(n2);
            }
            e3.apply(this, t2);
          }));
        };
        e2.exports = (e3, r2) => {
          r2 = Object.assign({ exclude: [/.+(Sync|Stream)$/], errorFirst: true, promiseModule: Promise }, r2);
          const t2 = typeof e3;
          if (!(e3 !== null && (t2 === "object" || t2 === "function"))) {
            throw new TypeError(`Expected \`input\` to be a \`Function\` or \`Object\`, got \`${e3 === null ? "null" : t2}\``);
          }
          const filter = (e4) => {
            const match = (r3) => typeof r3 === "string" ? e4 === r3 : r3.test(e4);
            return r2.include ? r2.include.some(match) : !r2.exclude.some(match);
          };
          let n;
          if (t2 === "function") {
            n = function(...t3) {
              return r2.excludeMain ? e3(...t3) : processFn(e3, r2).apply(this, t3);
            };
          } else {
            n = Object.create(Object.getPrototypeOf(e3));
          }
          for (const t3 in e3) {
            const o = e3[t3];
            n[t3] = typeof o === "function" && filter(t3) ? processFn(o, r2) : o;
          }
          return n;
        };
      }, 147: (e2) => {
        "use strict";
        e2.exports = require_fs();
      }, 781: (e2) => {
        "use strict";
        e2.exports = require_stream();
      }, 796: (e2) => {
        "use strict";
        e2.exports = require_zlib();
      } };
      var r = {};
      function __nccwpck_require__2(t2) {
        var n = r[t2];
        if (n !== void 0) {
          return n.exports;
        }
        var o = r[t2] = { exports: {} };
        var i = true;
        try {
          e[t2](o, o.exports, __nccwpck_require__2);
          i = false;
        } finally {
          if (i) delete r[t2];
        }
        return o.exports;
      }
      if (typeof __nccwpck_require__2 !== "undefined") __nccwpck_require__2.ab = __dirname + "/";
      var t = __nccwpck_require__2(349);
      module.exports = t;
    })();
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/bloom-filter.js
var require_bloom_filter = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/bloom-filter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "BloomFilter", {
      enumerable: true,
      get: function() {
        return BloomFilter;
      }
    });
    function murmurhash2(str) {
      let h = 0;
      for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        h = Math.imul(h ^ c, 1540483477);
        h ^= h >>> 13;
        h = Math.imul(h, 1540483477);
      }
      return h >>> 0;
    }
    var DEFAULT_ERROR_RATE = 1e-4;
    var BloomFilter = class _BloomFilter {
      static from(items, errorRate) {
        if (errorRate === void 0) errorRate = DEFAULT_ERROR_RATE;
        const filter = new _BloomFilter(items.length, errorRate);
        for (const item of items) {
          filter.add(item);
        }
        return filter;
      }
      export() {
        const data = {
          numItems: this.numItems,
          errorRate: this.errorRate,
          numBits: this.numBits,
          numHashes: this.numHashes,
          bitArray: this.bitArray
        };
        if (process.env.NEXT_RUNTIME === "nodejs") {
          if (this.errorRate < DEFAULT_ERROR_RATE) {
            const filterData = JSON.stringify(data);
            const gzipSize = require_gzip_size().sync(filterData);
            if (gzipSize > 1024) {
              console.warn("Creating filter with error rate less than 0.1% (0.001) can increase the size dramatically proceed with caution. Received error rate " + this.errorRate + " resulted in size " + filterData.length + " bytes, " + gzipSize + " bytes (gzip)");
            }
          }
        }
        return data;
      }
      import(data) {
        this.numItems = data.numItems;
        this.errorRate = data.errorRate;
        this.numBits = data.numBits;
        this.numHashes = data.numHashes;
        this.bitArray = data.bitArray;
      }
      add(item) {
        const hashValues = this.getHashValues(item);
        hashValues.forEach((hash) => {
          this.bitArray[hash] = 1;
        });
      }
      contains(item) {
        const hashValues = this.getHashValues(item);
        return hashValues.every((hash) => this.bitArray[hash]);
      }
      getHashValues(item) {
        const hashValues = [];
        for (let i = 1; i <= this.numHashes; i++) {
          const hash = murmurhash2("" + item + i) % this.numBits;
          hashValues.push(hash);
        }
        return hashValues;
      }
      constructor(numItems, errorRate = DEFAULT_ERROR_RATE) {
        this.numItems = numItems;
        this.errorRate = errorRate;
        this.numBits = Math.ceil(-(numItems * Math.log(errorRate)) / (Math.log(2) * Math.log(2)));
        this.numHashes = Math.ceil(this.numBits / numItems * Math.log(2));
        this.bitArray = new Array(this.numBits).fill(0);
      }
    };
  }
});

// portfolio-site/node_modules/next/dist/compiled/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "portfolio-site/node_modules/next/dist/compiled/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    (function() {
      function typeOf(object) {
        if ("object" === typeof object && null !== object) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              switch (object = object.type, object) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_VIEW_TRANSITION_TYPE:
                  return object;
                default:
                  switch (object = object && object.$$typeof, object) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                      return object;
                    case REACT_CONSUMER_TYPE:
                      return object;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo"), REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = /* @__PURE__ */ Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for("react.client.reference");
      exports.ContextConsumer = REACT_CONSUMER_TYPE;
      exports.ContextProvider = REACT_CONTEXT_TYPE;
      exports.Element = REACT_ELEMENT_TYPE;
      exports.ForwardRef = REACT_FORWARD_REF_TYPE;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Lazy = REACT_LAZY_TYPE;
      exports.Memo = REACT_MEMO_TYPE;
      exports.Portal = REACT_PORTAL_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
      exports.isContextConsumer = function(object) {
        return typeOf(object) === REACT_CONSUMER_TYPE;
      };
      exports.isContextProvider = function(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      };
      exports.isElement = function(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      };
      exports.isForwardRef = function(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      };
      exports.isFragment = function(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      };
      exports.isLazy = function(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      };
      exports.isMemo = function(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      };
      exports.isPortal = function(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      };
      exports.isProfiler = function(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      };
      exports.isStrictMode = function(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      };
      exports.isSuspense = function(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      };
      exports.isSuspenseList = function(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      };
      exports.isValidElementType = function(type) {
        return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
      };
      exports.typeOf = typeOf;
    })();
  }
});

// portfolio-site/node_modules/next/dist/compiled/react-is/index.js
var require_react_is = __commonJS({
  "portfolio-site/node_modules/next/dist/compiled/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router/router.js
var require_router = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router/router.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      createKey: function() {
        return createKey;
      },
      default: function() {
        return Router;
      },
      matchesMiddleware: function() {
        return matchesMiddleware;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _interop_require_wildcard = require_interop_require_wildcard();
    var _removetrailingslash = require_remove_trailing_slash();
    var _routeloader = require_route_loader();
    var _script = require_script();
    var _iserror = _interop_require_wildcard._(require_is_error());
    var _denormalizepagepath = require_denormalize_page_path();
    var _normalizelocalepath = require_normalize_locale_path();
    var _mitt = _interop_require_default._(require_mitt());
    var _utils = require_utils2();
    var _isdynamic = require_is_dynamic();
    var _parserelativeurl = require_parse_relative_url();
    var _routematcher = require_route_matcher();
    var _routeregex = require_route_regex();
    var _formaturl = require_format_url();
    var _detectdomainlocale = require_detect_domain_locale2();
    var _parsepath = require_parse_path();
    var _addlocale = require_add_locale2();
    var _removelocale = require_remove_locale();
    var _removebasepath = require_remove_base_path();
    var _addbasepath = require_add_base_path();
    var _hasbasepath = require_has_base_path();
    var _resolvehref = require_resolve_href();
    var _isapiroute = require_is_api_route();
    var _getnextpathnameinfo = require_get_next_pathname_info();
    var _formatnextpathnameinfo = require_format_next_pathname_info();
    var _comparestates = require_compare_states();
    var _islocalurl = require_is_local_url();
    var _isbot = require_is_bot();
    var _omit = require_omit();
    var _interpolateas = require_interpolate_as();
    var _disablesmoothscroll = require_disable_smooth_scroll();
    var _constants = require_constants();
    var resolveRewrites;
    if (process.env.__NEXT_HAS_REWRITES) {
      resolveRewrites = require_resolve_rewrites().default;
    }
    function buildCancellationError() {
      return Object.assign(Object.defineProperty(new Error("Route Cancelled"), "__NEXT_ERROR_CODE", {
        value: "E315",
        enumerable: false,
        configurable: true
      }), {
        cancelled: true
      });
    }
    async function matchesMiddleware(options) {
      const matchers = await Promise.resolve(options.router.pageLoader.getMiddleware());
      if (!matchers) return false;
      const { pathname: asPathname } = (0, _parsepath.parsePath)(options.asPath);
      const cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;
      const asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));
      return matchers.some((m) => new RegExp(m.regexp).test(asWithBasePathAndLocale));
    }
    function stripOrigin(url) {
      const origin = (0, _utils.getLocationOrigin)();
      return url.startsWith(origin) ? url.substring(origin.length) : url;
    }
    function prepareUrlAs(router, url, as) {
      let [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(router, url, true);
      const origin = (0, _utils.getLocationOrigin)();
      const hrefWasAbsolute = resolvedHref.startsWith(origin);
      const asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);
      resolvedHref = stripOrigin(resolvedHref);
      resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;
      const preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);
      const preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;
      return {
        url: preparedUrl,
        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)
      };
    }
    function resolveDynamicRoute(pathname, pages) {
      const cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));
      if (cleanPathname === "/404" || cleanPathname === "/_error") {
        return pathname;
      }
      if (!pages.includes(cleanPathname)) {
        pages.some((page) => {
          if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {
            pathname = page;
            return true;
          }
        });
      }
      return (0, _removetrailingslash.removeTrailingSlash)(pathname);
    }
    function getMiddlewareData(source, response, options) {
      const nextConfig = {
        basePath: options.router.basePath,
        i18n: {
          locales: options.router.locales
        },
        trailingSlash: Boolean(process.env.__NEXT_TRAILING_SLASH)
      };
      const rewriteHeader = response.headers.get("x-nextjs-rewrite");
      let rewriteTarget = rewriteHeader || response.headers.get("x-nextjs-matched-path");
      const matchedPath = response.headers.get(_constants.MATCHED_PATH_HEADER);
      if (matchedPath && !rewriteTarget && !matchedPath.includes("__next_data_catchall") && !matchedPath.includes("/_error") && !matchedPath.includes("/404")) {
        rewriteTarget = matchedPath;
      }
      if (rewriteTarget) {
        if (rewriteTarget.startsWith("/") || process.env.__NEXT_EXTERNAL_MIDDLEWARE_REWRITE_RESOLVE) {
          const parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);
          const pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {
            nextConfig,
            parseData: true
          });
          let fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);
          return Promise.all([
            options.router.pageLoader.getPageList(),
            (0, _routeloader.getClientBuildManifest)()
          ]).then((param) => {
            let [pages, { __rewrites: rewrites }] = param;
            let as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);
            if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {
              const parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {
                nextConfig: process.env.__NEXT_HAS_REWRITES ? void 0 : nextConfig,
                parseData: true
              });
              as = (0, _addbasepath.addBasePath)(parsedSource.pathname);
              parsedRewriteTarget.pathname = as;
            }
            if (process.env.__NEXT_HAS_REWRITES) {
              const result = resolveRewrites(as, pages, rewrites, parsedRewriteTarget.query, (path) => resolveDynamicRoute(path, pages), options.router.locales);
              if (result.matchedPage) {
                parsedRewriteTarget.pathname = result.parsedAs.pathname;
                as = parsedRewriteTarget.pathname;
                Object.assign(parsedRewriteTarget.query, result.parsedAs.query);
              }
            } else if (!pages.includes(fsPathname)) {
              const resolvedPathname = resolveDynamicRoute(fsPathname, pages);
              if (resolvedPathname !== fsPathname) {
                fsPathname = resolvedPathname;
              }
            }
            const resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;
            if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {
              const matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);
              Object.assign(parsedRewriteTarget.query, matches || {});
            }
            return {
              type: "rewrite",
              parsedAs: parsedRewriteTarget,
              resolvedHref
            };
          });
        }
        const src = (0, _parsepath.parsePath)(source);
        const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({
          ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {
            nextConfig,
            parseData: true
          }),
          defaultLocale: options.router.defaultLocale,
          buildId: ""
        });
        return Promise.resolve({
          type: "redirect-external",
          destination: "" + pathname + src.query + src.hash
        });
      }
      const redirectTarget = response.headers.get("x-nextjs-redirect");
      if (redirectTarget) {
        if (redirectTarget.startsWith("/")) {
          const src = (0, _parsepath.parsePath)(redirectTarget);
          const pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)({
            ...(0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {
              nextConfig,
              parseData: true
            }),
            defaultLocale: options.router.defaultLocale,
            buildId: ""
          });
          return Promise.resolve({
            type: "redirect-internal",
            newAs: "" + pathname + src.query + src.hash,
            newUrl: "" + pathname + src.query + src.hash
          });
        }
        return Promise.resolve({
          type: "redirect-external",
          destination: redirectTarget
        });
      }
      return Promise.resolve({
        type: "next"
      });
    }
    async function withMiddlewareEffects(options) {
      const matches = await matchesMiddleware(options);
      if (!matches || !options.fetchData) {
        return null;
      }
      const data = await options.fetchData();
      const effect = await getMiddlewareData(data.dataHref, data.response, options);
      return {
        dataHref: data.dataHref,
        json: data.json,
        response: data.response,
        text: data.text,
        cacheKey: data.cacheKey,
        effect
      };
    }
    var manualScrollRestoration = process.env.__NEXT_SCROLL_RESTORATION && typeof window !== "undefined" && "scrollRestoration" in window.history && !!(function() {
      try {
        let v = "__next";
        return sessionStorage.setItem(v, v), sessionStorage.removeItem(v), true;
      } catch (n) {
      }
    })();
    var SSG_DATA_NOT_FOUND = /* @__PURE__ */ Symbol("SSG_DATA_NOT_FOUND");
    function fetchRetry(url, attempts, options) {
      return fetch(url, {
        // Cookies are required to be present for Next.js' SSG "Preview Mode".
        // Cookies may also be required for `getServerSideProps`.
        //
        // > `fetch` wont send cookies, unless you set the credentials init
        // > option.
        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch
        //
        // > For maximum browser compatibility when it comes to sending &
        // > receiving cookies, always supply the `credentials: 'same-origin'`
        // > option instead of relying on the default.
        // https://github.com/github/fetch#caveats
        credentials: "same-origin",
        method: options.method || "GET",
        headers: Object.assign({}, options.headers, {
          "x-nextjs-data": "1"
        })
      }).then((response) => {
        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;
      });
    }
    function tryToParseAsJSON(text) {
      try {
        return JSON.parse(text);
      } catch (error) {
        return null;
      }
    }
    function fetchNextData(param) {
      let { dataHref, inflightCache, isPrefetch, hasMiddleware, isServerRender, parseJSON, persistCache, isBackground, unstable_skipClientCache } = param;
      const { href: cacheKey } = new URL(dataHref, window.location.href);
      const getData = (params) => {
        var _params_method;
        return fetchRetry(dataHref, isServerRender ? 3 : 1, {
          headers: Object.assign({}, isPrefetch ? {
            purpose: "prefetch"
          } : {}, isPrefetch && hasMiddleware ? {
            "x-middleware-prefetch": "1"
          } : {}, process.env.NEXT_DEPLOYMENT_ID ? {
            "x-deployment-id": process.env.NEXT_DEPLOYMENT_ID
          } : {}),
          method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : "GET"
        }).then((response) => {
          if (response.ok && (params == null ? void 0 : params.method) === "HEAD") {
            return {
              dataHref,
              response,
              text: "",
              json: {},
              cacheKey
            };
          }
          return response.text().then((text) => {
            if (!response.ok) {
              if (hasMiddleware && [
                301,
                302,
                307,
                308
              ].includes(response.status)) {
                return {
                  dataHref,
                  response,
                  text,
                  json: {},
                  cacheKey
                };
              }
              if (response.status === 404) {
                var _tryToParseAsJSON;
                if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {
                  return {
                    dataHref,
                    json: {
                      notFound: SSG_DATA_NOT_FOUND
                    },
                    response,
                    text,
                    cacheKey
                  };
                }
              }
              const error = Object.defineProperty(new Error("Failed to load static props"), "__NEXT_ERROR_CODE", {
                value: "E124",
                enumerable: false,
                configurable: true
              });
              if (!isServerRender) {
                (0, _routeloader.markAssetError)(error);
              }
              throw error;
            }
            return {
              dataHref,
              json: parseJSON ? tryToParseAsJSON(text) : null,
              response,
              text,
              cacheKey
            };
          });
        }).then((data) => {
          if (!persistCache || true) {
            delete inflightCache[cacheKey];
          }
          return data;
        }).catch((err) => {
          if (!unstable_skipClientCache) {
            delete inflightCache[cacheKey];
          }
          if (
            // chrome
            err.message === "Failed to fetch" || // firefox
            err.message === "NetworkError when attempting to fetch resource." || // safari
            err.message === "Load failed"
          ) {
            (0, _routeloader.markAssetError)(err);
          }
          throw err;
        });
      };
      if (unstable_skipClientCache && persistCache) {
        return getData({}).then((data) => {
          if (data.response.headers.get("x-middleware-cache") !== "no-cache") {
            inflightCache[cacheKey] = Promise.resolve(data);
          }
          return data;
        });
      }
      if (inflightCache[cacheKey] !== void 0) {
        return inflightCache[cacheKey];
      }
      return inflightCache[cacheKey] = getData(isBackground ? {
        method: "HEAD"
      } : {});
    }
    function createKey() {
      return Math.random().toString(36).slice(2, 10);
    }
    function handleHardNavigation(param) {
      let { url, router } = param;
      if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {
        throw Object.defineProperty(new Error("Invariant: attempted to hard navigate to the same URL " + url + " " + location.href), "__NEXT_ERROR_CODE", {
          value: "E282",
          enumerable: false,
          configurable: true
        });
      }
      window.location.href = url;
    }
    var getCancelledHandler = (param) => {
      let { route, router } = param;
      let cancelled = false;
      const cancel = router.clc = () => {
        cancelled = true;
      };
      const handleCancelled = () => {
        if (cancelled) {
          const error = Object.defineProperty(new Error('Abort fetching component for route: "' + route + '"'), "__NEXT_ERROR_CODE", {
            value: "E483",
            enumerable: false,
            configurable: true
          });
          error.cancelled = true;
          throw error;
        }
        if (cancel === router.clc) {
          router.clc = null;
        }
      };
      return handleCancelled;
    };
    var Router = class _Router {
      reload() {
        window.location.reload();
      }
      /**
      * Go back in history
      */
      back() {
        window.history.back();
      }
      /**
      * Go forward in history
      */
      forward() {
        window.history.forward();
      }
      /**
      * Performs a `pushState` with arguments
      * @param url of the route
      * @param as masks `url` for the browser
      * @param options object you can define `shallow` and other options
      */
      push(url, as, options) {
        if (options === void 0) options = {};
        if (process.env.__NEXT_SCROLL_RESTORATION) {
          if (manualScrollRestoration) {
            try {
              sessionStorage.setItem("__next_scroll_" + this._key, JSON.stringify({
                x: self.pageXOffset,
                y: self.pageYOffset
              }));
            } catch (e) {
            }
          }
        }
        ;
        ({ url, as } = prepareUrlAs(this, url, as));
        return this.change("pushState", url, as, options);
      }
      /**
      * Performs a `replaceState` with arguments
      * @param url of the route
      * @param as masks `url` for the browser
      * @param options object you can define `shallow` and other options
      */
      replace(url, as, options) {
        if (options === void 0) options = {};
        ;
        ({ url, as } = prepareUrlAs(this, url, as));
        return this.change("replaceState", url, as, options);
      }
      async _bfl(as, resolvedAs, locale, skipNavigate) {
        if (process.env.__NEXT_CLIENT_ROUTER_FILTER_ENABLED) {
          if (!this._bfl_s && !this._bfl_d) {
            const { BloomFilter } = require_bloom_filter();
            let staticFilterData;
            let dynamicFilterData;
            try {
              ;
              ({ __routerFilterStatic: staticFilterData, __routerFilterDynamic: dynamicFilterData } = await (0, _routeloader.getClientBuildManifest)());
            } catch (err) {
              console.error(err);
              if (skipNavigate) {
                return true;
              }
              handleHardNavigation({
                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),
                router: this
              });
              return new Promise(() => {
              });
            }
            const routerFilterSValue = process.env.__NEXT_CLIENT_ROUTER_S_FILTER;
            if (!staticFilterData && routerFilterSValue) {
              staticFilterData = routerFilterSValue ? routerFilterSValue : void 0;
            }
            const routerFilterDValue = process.env.__NEXT_CLIENT_ROUTER_D_FILTER;
            if (!dynamicFilterData && routerFilterDValue) {
              dynamicFilterData = routerFilterDValue ? routerFilterDValue : void 0;
            }
            if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {
              this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);
              this._bfl_s.import(staticFilterData);
            }
            if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {
              this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);
              this._bfl_d.import(dynamicFilterData);
            }
          }
          let matchesBflStatic = false;
          let matchesBflDynamic = false;
          const pathsToCheck = [
            {
              as
            },
            {
              as: resolvedAs
            }
          ];
          for (const { as: curAs, allowMatchCurrent } of pathsToCheck) {
            if (curAs) {
              const asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, "http://n").pathname);
              const asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || this.locale));
              if (allowMatchCurrent || asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(this.asPath, "http://n").pathname)) {
                var _this__bfl_s, _this__bfl_s1;
                matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));
                for (const normalizedAS of [
                  asNoSlash,
                  asNoSlashLocale
                ]) {
                  const curAsParts = normalizedAS.split("/");
                  for (let i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++) {
                    var _this__bfl_d;
                    const currentPart = curAsParts.slice(0, i).join("/");
                    if (currentPart && ((_this__bfl_d = this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {
                      matchesBflDynamic = true;
                      break;
                    }
                  }
                }
                if (matchesBflStatic || matchesBflDynamic) {
                  if (skipNavigate) {
                    return true;
                  }
                  handleHardNavigation({
                    url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || this.locale, this.defaultLocale)),
                    router: this
                  });
                  return new Promise(() => {
                  });
                }
              }
            }
          }
        }
        return false;
      }
      async change(method, url, as, options, forcedScroll) {
        var _this_components_pathname;
        if (!(0, _islocalurl.isLocalURL)(url)) {
          handleHardNavigation({
            url,
            router: this
          });
          return false;
        }
        const isQueryUpdating = options._h === 1;
        if (!isQueryUpdating && !options.shallow) {
          await this._bfl(as, void 0, options.locale);
        }
        let shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;
        const nextState = {
          ...this.state
        };
        const readyStateChange = this.isReady !== true;
        this.isReady = true;
        const isSsr = this.isSsr;
        if (!isQueryUpdating) {
          this.isSsr = false;
        }
        if (isQueryUpdating && this.clc) {
          return false;
        }
        const prevLocale = nextState.locale;
        if (process.env.__NEXT_I18N_SUPPORT) {
          nextState.locale = options.locale === false ? this.defaultLocale : options.locale || nextState.locale;
          if (typeof options.locale === "undefined") {
            options.locale = nextState.locale;
          }
          const parsedAs = (0, _parserelativeurl.parseRelativeUrl)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as);
          const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);
          if (localePathResult.detectedLocale) {
            nextState.locale = localePathResult.detectedLocale;
            parsedAs.pathname = (0, _addbasepath.addBasePath)(parsedAs.pathname);
            as = (0, _formaturl.formatWithValidation)(parsedAs);
            url = (0, _addbasepath.addBasePath)((0, _normalizelocalepath.normalizeLocalePath)((0, _hasbasepath.hasBasePath)(url) ? (0, _removebasepath.removeBasePath)(url) : url, this.locales).pathname);
          }
          let didNavigate = false;
          if (process.env.__NEXT_I18N_SUPPORT) {
            var _this_locales;
            if (!((_this_locales = this.locales) == null ? void 0 : _this_locales.includes(nextState.locale))) {
              parsedAs.pathname = (0, _addlocale.addLocale)(parsedAs.pathname, nextState.locale);
              handleHardNavigation({
                url: (0, _formaturl.formatWithValidation)(parsedAs),
                router: this
              });
              didNavigate = true;
            }
          }
          const detectedDomain = (0, _detectdomainlocale.detectDomainLocale)(this.domainLocales, void 0, nextState.locale);
          if (process.env.__NEXT_I18N_SUPPORT) {
            if (!didNavigate && detectedDomain && this.isLocaleDomain && self.location.hostname !== detectedDomain.domain) {
              const asNoBasePath = (0, _removebasepath.removeBasePath)(as);
              handleHardNavigation({
                url: "http" + (detectedDomain.http ? "" : "s") + "://" + detectedDomain.domain + (0, _addbasepath.addBasePath)((nextState.locale === detectedDomain.defaultLocale ? "" : "/" + nextState.locale) + (asNoBasePath === "/" ? "" : asNoBasePath) || "/"),
                router: this
              });
              didNavigate = true;
            }
          }
          if (didNavigate) {
            return new Promise(() => {
            });
          }
        }
        if (_utils.ST) {
          performance.mark("routeChange");
        }
        const { shallow = false, scroll = true } = options;
        const routeProps = {
          shallow
        };
        if (this._inFlightRoute && this.clc) {
          if (!isSsr) {
            _Router.events.emit("routeChangeError", buildCancellationError(), this._inFlightRoute, routeProps);
          }
          this.clc();
          this.clc = null;
        }
        as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, this.defaultLocale));
        const cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);
        this._inFlightRoute = as;
        const localeChange = prevLocale !== nextState.locale;
        if (!isQueryUpdating && this.onlyAHashChange(cleanedAs) && !localeChange) {
          nextState.asPath = cleanedAs;
          _Router.events.emit("hashChangeStart", as, routeProps);
          this.changeState(method, url, as, {
            ...options,
            scroll: false
          });
          if (scroll) {
            this.scrollToHash(cleanedAs);
          }
          try {
            await this.set(nextState, this.components[nextState.route], null);
          } catch (err) {
            if ((0, _iserror.default)(err) && err.cancelled) {
              _Router.events.emit("routeChangeError", err, cleanedAs, routeProps);
            }
            throw err;
          }
          _Router.events.emit("hashChangeComplete", as, routeProps);
          return true;
        }
        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);
        let { pathname, query } = parsed;
        let pages, rewrites;
        try {
          ;
          [pages, { __rewrites: rewrites }] = await Promise.all([
            this.pageLoader.getPageList(),
            (0, _routeloader.getClientBuildManifest)(),
            this.pageLoader.getMiddleware()
          ]);
        } catch (err) {
          handleHardNavigation({
            url: as,
            router: this
          });
          return false;
        }
        if (!this.urlIsNew(cleanedAs) && !localeChange) {
          method = "replaceState";
        }
        let resolvedAs = as;
        pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;
        let route = (0, _removetrailingslash.removeTrailingSlash)(pathname);
        const parsedAsPathname = as.startsWith("/") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;
        if ((_this_components_pathname = this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {
          handleHardNavigation({
            url: as,
            router: this
          });
          return new Promise(() => {
          });
        }
        const isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));
        const isMiddlewareMatch = !options.shallow && await matchesMiddleware({
          asPath: as,
          locale: nextState.locale,
          router: this
        });
        if (isQueryUpdating && isMiddlewareMatch) {
          shouldResolveHref = false;
        }
        if (shouldResolveHref && pathname !== "/_error") {
          ;
          options._shouldResolveHref = true;
          if (process.env.__NEXT_HAS_REWRITES && as.startsWith("/")) {
            const rewritesResult = resolveRewrites((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, nextState.locale), true), pages, rewrites, query, (p) => resolveDynamicRoute(p, pages), this.locales);
            if (rewritesResult.externalDest) {
              handleHardNavigation({
                url: as,
                router: this
              });
              return true;
            }
            if (!isMiddlewareMatch) {
              resolvedAs = rewritesResult.asPath;
            }
            if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {
              pathname = rewritesResult.resolvedHref;
              parsed.pathname = (0, _addbasepath.addBasePath)(pathname);
              if (!isMiddlewareMatch) {
                url = (0, _formaturl.formatWithValidation)(parsed);
              }
            }
          } else {
            parsed.pathname = resolveDynamicRoute(pathname, pages);
            if (parsed.pathname !== pathname) {
              pathname = parsed.pathname;
              parsed.pathname = (0, _addbasepath.addBasePath)(pathname);
              if (!isMiddlewareMatch) {
                url = (0, _formaturl.formatWithValidation)(parsed);
              }
            }
          }
        }
        if (!(0, _islocalurl.isLocalURL)(as)) {
          if (true) {
            throw Object.defineProperty(new Error('Invalid href: "' + url + '" and as: "' + as + '", received relative href and external as\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as'), "__NEXT_ERROR_CODE", {
              value: "E380",
              enumerable: false,
              configurable: true
            });
          }
          handleHardNavigation({
            url: as,
            router: this
          });
          return false;
        }
        resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);
        route = (0, _removetrailingslash.removeTrailingSlash)(pathname);
        let routeMatch = false;
        if ((0, _isdynamic.isDynamicRoute)(route)) {
          const parsedAs = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);
          const asPathname = parsedAs.pathname;
          const routeRegex = (0, _routeregex.getRouteRegex)(route);
          routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);
          const shouldInterpolate = route === asPathname;
          const interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};
          if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {
            const missingParams = Object.keys(routeRegex.groups).filter((param) => !query[param] && !routeRegex.groups[param].optional);
            if (missingParams.length > 0 && !isMiddlewareMatch) {
              if (true) {
                console.warn((shouldInterpolate ? "Interpolating href" : "Mismatching `as` and `href`") + " failed to manually provide " + ("the params: " + missingParams.join(", ") + " in the `href`'s `query`"));
              }
              throw Object.defineProperty(new Error((shouldInterpolate ? "The provided `href` (" + url + ") value is missing query values (" + missingParams.join(", ") + ") to be interpolated properly. " : "The provided `as` value (" + asPathname + ") is incompatible with the `href` value (" + route + "). ") + ("Read more: https://nextjs.org/docs/messages/" + (shouldInterpolate ? "href-interpolation-failed" : "incompatible-href-as"))), "__NEXT_ERROR_CODE", {
                value: "E344",
                enumerable: false,
                configurable: true
              });
            }
          } else if (shouldInterpolate) {
            as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs, {
              pathname: interpolatedAs.result,
              query: (0, _omit.omit)(query, interpolatedAs.params)
            }));
          } else {
            Object.assign(query, routeMatch);
          }
        }
        if (!isQueryUpdating) {
          _Router.events.emit("routeChangeStart", as, routeProps);
        }
        const isErrorRoute = this.pathname === "/404" || this.pathname === "/_error";
        try {
          var _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props;
          let routeInfo = await this.getRouteInfo({
            route,
            pathname,
            query,
            as,
            resolvedAs,
            routeProps,
            locale: nextState.locale,
            isPreview: nextState.isPreview,
            hasMiddleware: isMiddlewareMatch,
            unstable_skipClientCache: options.unstable_skipClientCache,
            isQueryUpdating: isQueryUpdating && !this.isFallback,
            isMiddlewareRewrite
          });
          if (!isQueryUpdating && !options.shallow) {
            await this._bfl(as, "resolvedAs" in routeInfo ? routeInfo.resolvedAs : void 0, nextState.locale);
          }
          if ("route" in routeInfo && isMiddlewareMatch) {
            pathname = routeInfo.route || route;
            route = pathname;
            if (!routeProps.shallow) {
              query = Object.assign({}, routeInfo.query || {}, query);
            }
            const cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;
            if (routeMatch && pathname !== cleanedParsedPathname) {
              Object.keys(routeMatch).forEach((key) => {
                if (routeMatch && query[key] === routeMatch[key]) {
                  delete query[key];
                }
              });
            }
            if ((0, _isdynamic.isDynamicRoute)(pathname)) {
              const prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);
              let rewriteAs = prefixedAs;
              if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {
                rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);
              }
              if (process.env.__NEXT_I18N_SUPPORT) {
                const localeResult = (0, _normalizelocalepath.normalizeLocalePath)(rewriteAs, this.locales);
                nextState.locale = localeResult.detectedLocale || nextState.locale;
                rewriteAs = localeResult.pathname;
              }
              const routeRegex = (0, _routeregex.getRouteRegex)(pathname);
              const curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(new URL(rewriteAs, location.href).pathname);
              if (curRouteMatch) {
                Object.assign(query, curRouteMatch);
              }
            }
          }
          if ("type" in routeInfo) {
            if (routeInfo.type === "redirect-internal") {
              return this.change(method, routeInfo.newUrl, routeInfo.newAs, options);
            } else {
              handleHardNavigation({
                url: routeInfo.destination,
                router: this
              });
              return new Promise(() => {
              });
            }
          }
          const component = routeInfo.Component;
          if (component && component.unstable_scriptLoader) {
            const scripts = [].concat(component.unstable_scriptLoader());
            scripts.forEach((script) => {
              (0, _script.handleClientScriptLoad)(script.props);
            });
          }
          if ((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props) {
            if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {
              options.locale = false;
              const destination = routeInfo.props.pageProps.__N_REDIRECT;
              if (destination.startsWith("/") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {
                const parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);
                parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);
                const { url: newUrl, as: newAs } = prepareUrlAs(this, destination, destination);
                return this.change(method, newUrl, newAs, options);
              }
              handleHardNavigation({
                url: destination,
                router: this
              });
              return new Promise(() => {
              });
            }
            nextState.isPreview = !!routeInfo.props.__N_PREVIEW;
            if (routeInfo.props.notFound === SSG_DATA_NOT_FOUND) {
              let notFoundRoute;
              try {
                await this.fetchComponent("/404");
                notFoundRoute = "/404";
              } catch (_) {
                notFoundRoute = "/_error";
              }
              routeInfo = await this.getRouteInfo({
                route: notFoundRoute,
                pathname: notFoundRoute,
                query,
                as,
                resolvedAs,
                routeProps: {
                  shallow: false
                },
                locale: nextState.locale,
                isPreview: nextState.isPreview,
                isNotFound: true
              });
              if ("type" in routeInfo) {
                throw Object.defineProperty(new Error("Unexpected middleware effect on /404"), "__NEXT_ERROR_CODE", {
                  value: "E158",
                  enumerable: false,
                  configurable: true
                });
              }
            }
          }
          if (isQueryUpdating && this.pathname === "/_error" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {
            routeInfo.props.pageProps.statusCode = 500;
          }
          var _routeInfo_route;
          const isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);
          var _options_scroll;
          const shouldScroll = (_options_scroll = options.scroll) != null ? _options_scroll : !isQueryUpdating && !isValidShallowRoute;
          const resetScroll = shouldScroll ? {
            x: 0,
            y: 0
          } : null;
          const upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;
          const upcomingRouterState = {
            ...nextState,
            route,
            pathname,
            query,
            asPath: cleanedAs,
            isFallback: false
          };
          if (isQueryUpdating && isErrorRoute) {
            var _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1;
            routeInfo = await this.getRouteInfo({
              route: this.pathname,
              pathname: this.pathname,
              query,
              as,
              resolvedAs,
              routeProps: {
                shallow: false
              },
              locale: nextState.locale,
              isPreview: nextState.isPreview,
              isQueryUpdating: isQueryUpdating && !this.isFallback
            });
            if ("type" in routeInfo) {
              throw Object.defineProperty(new Error("Unexpected middleware effect on " + this.pathname), "__NEXT_ERROR_CODE", {
                value: "E225",
                enumerable: false,
                configurable: true
              });
            }
            if (this.pathname === "/_error" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {
              routeInfo.props.pageProps.statusCode = 500;
            }
            try {
              await this.set(upcomingRouterState, routeInfo, upcomingScrollState);
            } catch (err) {
              if ((0, _iserror.default)(err) && err.cancelled) {
                _Router.events.emit("routeChangeError", err, cleanedAs, routeProps);
              }
              throw err;
            }
            return true;
          }
          _Router.events.emit("beforeHistoryChange", as, routeProps);
          this.changeState(method, url, as, options);
          const canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, this.state);
          if (!canSkipUpdating) {
            try {
              await this.set(upcomingRouterState, routeInfo, upcomingScrollState);
            } catch (e) {
              if (e.cancelled) routeInfo.error = routeInfo.error || e;
              else throw e;
            }
            if (routeInfo.error) {
              if (!isQueryUpdating) {
                _Router.events.emit("routeChangeError", routeInfo.error, cleanedAs, routeProps);
              }
              throw routeInfo.error;
            }
            if (process.env.__NEXT_I18N_SUPPORT) {
              if (nextState.locale) {
                document.documentElement.lang = nextState.locale;
              }
            }
            if (!isQueryUpdating) {
              _Router.events.emit("routeChangeComplete", as, routeProps);
            }
            const hashRegex = /#.+$/;
            if (shouldScroll && hashRegex.test(as)) {
              this.scrollToHash(as);
            }
          }
          return true;
        } catch (err) {
          if ((0, _iserror.default)(err) && err.cancelled) {
            return false;
          }
          throw err;
        }
      }
      changeState(method, url, as, options) {
        if (options === void 0) options = {};
        if (true) {
          if (typeof window.history === "undefined") {
            console.error("Warning: window.history is not available.");
            return;
          }
          if (typeof window.history[method] === "undefined") {
            console.error("Warning: window.history." + method + " is not available");
            return;
          }
        }
        if (method !== "pushState" || (0, _utils.getURL)() !== as) {
          this._shallow = options.shallow;
          window.history[method](
            {
              url,
              as,
              options,
              __N: true,
              key: this._key = method !== "pushState" ? this._key : createKey()
            },
            // Most browsers currently ignores this parameter, although they may use it in the future.
            // Passing the empty string here should be safe against future changes to the method.
            // https://developer.mozilla.org/docs/Web/API/History/replaceState
            "",
            as
          );
        }
      }
      async handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {
        if (err.cancelled) {
          throw err;
        }
        if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {
          _Router.events.emit("routeChangeError", err, as, routeProps);
          handleHardNavigation({
            url: as,
            router: this
          });
          throw buildCancellationError();
        }
        console.error(err);
        try {
          let props;
          const { page: Component, styleSheets } = await this.fetchComponent("/_error");
          const routeInfo = {
            props,
            Component,
            styleSheets,
            err,
            error: err
          };
          if (!routeInfo.props) {
            try {
              routeInfo.props = await this.getInitialProps(Component, {
                err,
                pathname,
                query
              });
            } catch (gipErr) {
              console.error("Error in error page `getInitialProps`: ", gipErr);
              routeInfo.props = {};
            }
          }
          return routeInfo;
        } catch (routeInfoErr) {
          return this.handleRouteInfoError((0, _iserror.default)(routeInfoErr) ? routeInfoErr : Object.defineProperty(new Error(routeInfoErr + ""), "__NEXT_ERROR_CODE", {
            value: "E394",
            enumerable: false,
            configurable: true
          }), pathname, query, as, routeProps, true);
        }
      }
      async getRouteInfo(param) {
        let { route: requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound } = param;
        let route = requestedRoute;
        try {
          var _data_effect, _data_effect1, _data_effect2, _data_response;
          let existingInfo = this.components[route];
          if (routeProps.shallow && existingInfo && this.route === route) {
            return existingInfo;
          }
          const handleCancelled = getCancelledHandler({
            route,
            router: this
          });
          if (hasMiddleware) {
            existingInfo = void 0;
          }
          let cachedRouteInfo = existingInfo && !("initial" in existingInfo) && false ? existingInfo : void 0;
          const isBackground = isQueryUpdating;
          const fetchNextDataParams = {
            dataHref: this.pageLoader.getDataHref({
              href: (0, _formaturl.formatWithValidation)({
                pathname,
                query
              }),
              skipInterpolation: true,
              asPath: isNotFound ? "/404" : resolvedAs,
              locale
            }),
            hasMiddleware: true,
            isServerRender: this.isSsr,
            parseJSON: true,
            inflightCache: isBackground ? this.sbc : this.sdc,
            persistCache: !isPreview,
            isPrefetch: false,
            unstable_skipClientCache,
            isBackground
          };
          let data = isQueryUpdating && !isMiddlewareRewrite ? null : await withMiddlewareEffects({
            fetchData: () => fetchNextData(fetchNextDataParams),
            asPath: isNotFound ? "/404" : resolvedAs,
            locale,
            router: this
          }).catch((err) => {
            if (isQueryUpdating) {
              return null;
            }
            throw err;
          });
          if (data && (pathname === "/_error" || pathname === "/404")) {
            data.effect = void 0;
          }
          if (isQueryUpdating) {
            if (!data) {
              data = {
                json: self.__NEXT_DATA__.props
              };
            } else {
              data.json = self.__NEXT_DATA__.props;
            }
          }
          handleCancelled();
          if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === "redirect-internal" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === "redirect-external") {
            return data.effect;
          }
          if ((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === "rewrite") {
            const resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);
            const pages = await this.pageLoader.getPageList();
            if (!isQueryUpdating || pages.includes(resolvedRoute)) {
              route = resolvedRoute;
              pathname = data.effect.resolvedHref;
              query = {
                ...query,
                ...data.effect.parsedAs.query
              };
              resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, this.locales).pathname);
              existingInfo = this.components[route];
              if (routeProps.shallow && existingInfo && this.route === route && !hasMiddleware) {
                return {
                  ...existingInfo,
                  route
                };
              }
            }
          }
          if ((0, _isapiroute.isAPIRoute)(route)) {
            handleHardNavigation({
              url: as,
              router: this
            });
            return new Promise(() => {
            });
          }
          const routeInfo = cachedRouteInfo || await this.fetchComponent(route).then((res) => ({
            Component: res.page,
            styleSheets: res.styleSheets,
            __N_SSG: res.mod.__N_SSG,
            __N_SSP: res.mod.__N_SSP
          }));
          if (true) {
            const { isValidElementType } = require_react_is();
            if (!isValidElementType(routeInfo.Component)) {
              throw Object.defineProperty(new Error('The default export is not a React Component in page: "' + pathname + '"'), "__NEXT_ERROR_CODE", {
                value: "E286",
                enumerable: false,
                configurable: true
              });
            }
          }
          const wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get("x-middleware-skip");
          const shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;
          if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {
            delete this.sdc[data.dataHref];
          }
          const { props, cacheKey } = await this._getData(async () => {
            if (shouldFetchData) {
              if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {
                return {
                  cacheKey: data.cacheKey,
                  props: data.json
                };
              }
              const dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : this.pageLoader.getDataHref({
                href: (0, _formaturl.formatWithValidation)({
                  pathname,
                  query
                }),
                asPath: resolvedAs,
                locale
              });
              const fetched = await fetchNextData({
                dataHref,
                isServerRender: this.isSsr,
                parseJSON: true,
                inflightCache: wasBailedPrefetch ? {} : this.sdc,
                persistCache: !isPreview,
                isPrefetch: false,
                unstable_skipClientCache
              });
              return {
                cacheKey: fetched.cacheKey,
                props: fetched.json || {}
              };
            }
            return {
              headers: {},
              props: await this.getInitialProps(
                routeInfo.Component,
                // we provide AppTree later so this needs to be `any`
                {
                  pathname,
                  query,
                  asPath: as,
                  locale,
                  locales: this.locales,
                  defaultLocale: this.defaultLocale
                }
              )
            };
          });
          if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {
            delete this.sdc[cacheKey];
          }
          if (!this.isPreview && routeInfo.__N_SSG && false) {
            fetchNextData(Object.assign({}, fetchNextDataParams, {
              isBackground: true,
              persistCache: false,
              inflightCache: this.sbc
            })).catch(() => {
            });
          }
          props.pageProps = Object.assign({}, props.pageProps);
          routeInfo.props = props;
          routeInfo.route = route;
          routeInfo.query = query;
          routeInfo.resolvedAs = resolvedAs;
          this.components[route] = routeInfo;
          return routeInfo;
        } catch (err) {
          return this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps);
        }
      }
      set(state, data, resetScroll) {
        this.state = state;
        return this.sub(data, this.components["/_app"].Component, resetScroll);
      }
      /**
      * Callback to execute before replacing router state
      * @param cb callback to be executed
      */
      beforePopState(cb) {
        this._bps = cb;
      }
      onlyAHashChange(as) {
        if (!this.asPath) return false;
        const [oldUrlNoHash, oldHash] = this.asPath.split("#", 2);
        const [newUrlNoHash, newHash] = as.split("#", 2);
        if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {
          return true;
        }
        if (oldUrlNoHash !== newUrlNoHash) {
          return false;
        }
        return oldHash !== newHash;
      }
      scrollToHash(as) {
        const [, hash = ""] = as.split("#", 2);
        (0, _disablesmoothscroll.disableSmoothScrollDuringRouteTransition)(() => {
          if (hash === "" || hash === "top") {
            window.scrollTo(0, 0);
            return;
          }
          const rawHash = decodeURIComponent(hash);
          const idEl = document.getElementById(rawHash);
          if (idEl) {
            idEl.scrollIntoView();
            return;
          }
          const nameEl = document.getElementsByName(rawHash)[0];
          if (nameEl) {
            nameEl.scrollIntoView();
          }
        }, {
          onlyHashChange: this.onlyAHashChange(as)
        });
      }
      urlIsNew(asPath) {
        return this.asPath !== asPath;
      }
      /**
      * Prefetch page code, you may wait for the data during page rendering.
      * This feature only works in production!
      * @param url the href of prefetched page
      * @param asPath the as path of the prefetched page
      */
      async prefetch(url, asPath, options) {
        if (asPath === void 0) asPath = url;
        if (options === void 0) options = {};
        if (true) {
          return;
        }
        if (typeof window !== "undefined" && (0, _isbot.isBot)(window.navigator.userAgent)) {
          return;
        }
        let parsed = (0, _parserelativeurl.parseRelativeUrl)(url);
        const urlPathname = parsed.pathname;
        let { pathname, query } = parsed;
        const originalPathname = pathname;
        if (process.env.__NEXT_I18N_SUPPORT) {
          if (options.locale === false) {
            pathname = (0, _normalizelocalepath.normalizeLocalePath)(pathname, this.locales).pathname;
            parsed.pathname = pathname;
            url = (0, _formaturl.formatWithValidation)(parsed);
            let parsedAs = (0, _parserelativeurl.parseRelativeUrl)(asPath);
            const localePathResult = (0, _normalizelocalepath.normalizeLocalePath)(parsedAs.pathname, this.locales);
            parsedAs.pathname = localePathResult.pathname;
            options.locale = localePathResult.detectedLocale || this.defaultLocale;
            asPath = (0, _formaturl.formatWithValidation)(parsedAs);
          }
        }
        const pages = await this.pageLoader.getPageList();
        let resolvedAs = asPath;
        const locale = typeof options.locale !== "undefined" ? options.locale || void 0 : this.locale;
        const isMiddlewareMatch = await matchesMiddleware({
          asPath,
          locale,
          router: this
        });
        if (process.env.__NEXT_HAS_REWRITES && asPath.startsWith("/")) {
          let rewrites;
          ({ __rewrites: rewrites } = await (0, _routeloader.getClientBuildManifest)());
          const rewritesResult = resolveRewrites((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, this.locale), true), pages, rewrites, parsed.query, (p) => resolveDynamicRoute(p, pages), this.locales);
          if (rewritesResult.externalDest) {
            return;
          }
          if (!isMiddlewareMatch) {
            resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), this.locale);
          }
          if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {
            pathname = rewritesResult.resolvedHref;
            parsed.pathname = pathname;
            if (!isMiddlewareMatch) {
              url = (0, _formaturl.formatWithValidation)(parsed);
            }
          }
        }
        parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);
        if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {
          pathname = parsed.pathname;
          parsed.pathname = pathname;
          Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});
          if (!isMiddlewareMatch) {
            url = (0, _formaturl.formatWithValidation)(parsed);
          }
        }
        const data = process.env.__NEXT_MIDDLEWARE_PREFETCH === "strict" ? null : await withMiddlewareEffects({
          fetchData: () => fetchNextData({
            dataHref: this.pageLoader.getDataHref({
              href: (0, _formaturl.formatWithValidation)({
                pathname: originalPathname,
                query
              }),
              skipInterpolation: true,
              asPath: resolvedAs,
              locale
            }),
            hasMiddleware: true,
            isServerRender: false,
            parseJSON: true,
            inflightCache: this.sdc,
            persistCache: !this.isPreview,
            isPrefetch: true
          }),
          asPath,
          locale,
          router: this
        });
        if ((data == null ? void 0 : data.effect.type) === "rewrite") {
          parsed.pathname = data.effect.resolvedHref;
          pathname = data.effect.resolvedHref;
          query = {
            ...query,
            ...data.effect.parsedAs.query
          };
          resolvedAs = data.effect.parsedAs.pathname;
          url = (0, _formaturl.formatWithValidation)(parsed);
        }
        if ((data == null ? void 0 : data.effect.type) === "redirect-external") {
          return;
        }
        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);
        if (await this._bfl(asPath, resolvedAs, options.locale, true)) {
          this.components[urlPathname] = {
            __appRouter: true
          };
        }
        await Promise.all([
          this.pageLoader._isSsg(route).then((isSsg) => {
            return isSsg ? fetchNextData({
              dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : this.pageLoader.getDataHref({
                href: url,
                asPath: resolvedAs,
                locale
              }),
              isServerRender: false,
              parseJSON: true,
              inflightCache: this.sdc,
              persistCache: !this.isPreview,
              isPrefetch: true,
              unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!process.env.__NEXT_OPTIMISTIC_CLIENT_CACHE
            }).then(() => false).catch(() => false) : false;
          }),
          this.pageLoader[options.priority ? "loadPage" : "prefetch"](route)
        ]);
      }
      async fetchComponent(route) {
        const handleCancelled = getCancelledHandler({
          route,
          router: this
        });
        try {
          const componentResult = await this.pageLoader.loadPage(route);
          handleCancelled();
          return componentResult;
        } catch (err) {
          handleCancelled();
          throw err;
        }
      }
      _getData(fn) {
        let cancelled = false;
        const cancel = () => {
          cancelled = true;
        };
        this.clc = cancel;
        return fn().then((data) => {
          if (cancel === this.clc) {
            this.clc = null;
          }
          if (cancelled) {
            const err = Object.defineProperty(new Error("Loading initial props cancelled"), "__NEXT_ERROR_CODE", {
              value: "E405",
              enumerable: false,
              configurable: true
            });
            err.cancelled = true;
            throw err;
          }
          return data;
        });
      }
      getInitialProps(Component, ctx) {
        const { Component: App } = this.components["/_app"];
        const AppTree = this._wrapApp(App);
        ctx.AppTree = AppTree;
        return (0, _utils.loadGetInitialProps)(App, {
          AppTree,
          Component,
          router: this,
          ctx
        });
      }
      get route() {
        return this.state.route;
      }
      get pathname() {
        return this.state.pathname;
      }
      get query() {
        return this.state.query;
      }
      get asPath() {
        return this.state.asPath;
      }
      get locale() {
        return this.state.locale;
      }
      get isFallback() {
        return this.state.isFallback;
      }
      get isPreview() {
        return this.state.isPreview;
      }
      constructor(pathname, query, as, { initialProps, pageLoader, App, wrapApp, Component, err, subscription, isFallback, locale, locales, defaultLocale, domainLocales, isPreview }) {
        this.sdc = {};
        this.sbc = {};
        this.isFirstPopStateEvent = true;
        this._key = createKey();
        this.onPopState = (e) => {
          const { isFirstPopStateEvent } = this;
          this.isFirstPopStateEvent = false;
          const state = e.state;
          if (!state) {
            const { pathname: pathname3, query: query2 } = this;
            this.changeState("replaceState", (0, _formaturl.formatWithValidation)({
              pathname: (0, _addbasepath.addBasePath)(pathname3),
              query: query2
            }), (0, _utils.getURL)());
            return;
          }
          if (state.__NA) {
            window.location.reload();
            return;
          }
          if (!state.__N) {
            return;
          }
          if (isFirstPopStateEvent && this.locale === state.options.locale && state.as === this.asPath) {
            return;
          }
          let forcedScroll;
          const { url, as: as2, options, key } = state;
          if (process.env.__NEXT_SCROLL_RESTORATION) {
            if (manualScrollRestoration) {
              if (this._key !== key) {
                try {
                  sessionStorage.setItem("__next_scroll_" + this._key, JSON.stringify({
                    x: self.pageXOffset,
                    y: self.pageYOffset
                  }));
                } catch (e2) {
                }
                try {
                  const v = sessionStorage.getItem("__next_scroll_" + key);
                  forcedScroll = JSON.parse(v);
                } catch (e2) {
                  forcedScroll = {
                    x: 0,
                    y: 0
                  };
                }
              }
            }
          }
          this._key = key;
          const { pathname: pathname2 } = (0, _parserelativeurl.parseRelativeUrl)(url);
          if (this.isSsr && as2 === (0, _addbasepath.addBasePath)(this.asPath) && pathname2 === (0, _addbasepath.addBasePath)(this.pathname)) {
            return;
          }
          if (this._bps && !this._bps(state)) {
            return;
          }
          this.change("replaceState", url, as2, Object.assign({}, options, {
            shallow: options.shallow && this._shallow,
            locale: options.locale || this.defaultLocale,
            // @ts-ignore internal value not exposed on types
            _h: 0
          }), forcedScroll);
        };
        const route = (0, _removetrailingslash.removeTrailingSlash)(pathname);
        this.components = {};
        if (pathname !== "/_error") {
          this.components[route] = {
            Component,
            initial: true,
            props: initialProps,
            err,
            __N_SSG: initialProps && initialProps.__N_SSG,
            __N_SSP: initialProps && initialProps.__N_SSP
          };
        }
        this.components["/_app"] = {
          Component: App,
          styleSheets: []
        };
        this.events = _Router.events;
        this.pageLoader = pageLoader;
        const autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;
        this.basePath = process.env.__NEXT_ROUTER_BASEPATH || "";
        this.sub = subscription;
        this.clc = null;
        this._wrapApp = wrapApp;
        this.isSsr = true;
        this.isLocaleDomain = false;
        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.isExperimentalCompile || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !process.env.__NEXT_HAS_REWRITES);
        if (process.env.__NEXT_I18N_SUPPORT) {
          this.locales = locales;
          this.defaultLocale = defaultLocale;
          this.domainLocales = domainLocales;
          this.isLocaleDomain = !!(0, _detectdomainlocale.detectDomainLocale)(domainLocales, self.location.hostname);
        }
        this.state = {
          route,
          pathname,
          query,
          asPath: autoExportDynamic ? pathname : as,
          isPreview: !!isPreview,
          locale: process.env.__NEXT_I18N_SUPPORT ? locale : void 0,
          isFallback
        };
        this._initialMatchesMiddlewarePromise = Promise.resolve(false);
        if (typeof window !== "undefined") {
          if (!as.startsWith("//")) {
            const options = {
              locale
            };
            const asPath = (0, _utils.getURL)();
            this._initialMatchesMiddlewarePromise = matchesMiddleware({
              router: this,
              locale,
              asPath
            }).then((matches) => {
              ;
              options._shouldResolveHref = as !== pathname;
              this.changeState("replaceState", matches ? asPath : (0, _formaturl.formatWithValidation)({
                pathname: (0, _addbasepath.addBasePath)(pathname),
                query
              }), asPath, options);
              return matches;
            });
          }
          window.addEventListener("popstate", this.onPopState);
          if (process.env.__NEXT_SCROLL_RESTORATION) {
            if (manualScrollRestoration) {
              window.history.scrollRestoration = "manual";
            }
          }
        }
      }
    };
    Router.events = (0, _mitt.default)();
  }
});

// portfolio-site/node_modules/next/dist/shared/lib/router-context.shared-runtime.js
var require_router_context_shared_runtime = __commonJS({
  "portfolio-site/node_modules/next/dist/shared/lib/router-context.shared-runtime.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "RouterContext", {
      enumerable: true,
      get: function() {
        return RouterContext;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _react = _interop_require_default._(require_react());
    var RouterContext = _react.default.createContext(null);
    if (true) {
      RouterContext.displayName = "RouterContext";
    }
  }
});

// portfolio-site/node_modules/next/dist/client/with-router.js
var require_with_router = __commonJS({
  "portfolio-site/node_modules/next/dist/client/with-router.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function() {
        return withRouter3;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _jsxruntime = require_jsx_runtime();
    var _react = _interop_require_default._(require_react());
    var _router = require_router2();
    function withRouter3(ComposedComponent) {
      function WithRouterWrapper(props) {
        return (0, _jsxruntime.jsx)(ComposedComponent, {
          router: (0, _router.useRouter)(),
          ...props
        });
      }
      WithRouterWrapper.getInitialProps = ComposedComponent.getInitialProps;
      WithRouterWrapper.origGetInitialProps = ComposedComponent.origGetInitialProps;
      if (true) {
        const name = ComposedComponent.displayName || ComposedComponent.name || "Unknown";
        WithRouterWrapper.displayName = "withRouter(" + name + ")";
      }
      return WithRouterWrapper;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/next/dist/client/router.js
var require_router2 = __commonJS({
  "portfolio-site/node_modules/next/dist/client/router.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports, {
      Router: function() {
        return _router.default;
      },
      createRouter: function() {
        return createRouter2;
      },
      // Export the singletonRouter and this is the public API.
      default: function() {
        return _default;
      },
      makePublicRouterInstance: function() {
        return makePublicRouterInstance;
      },
      useRouter: function() {
        return useRouter3;
      },
      withRouter: function() {
        return _withrouter.default;
      }
    });
    var _interop_require_default = require_interop_require_default();
    var _react = _interop_require_default._(require_react());
    var _router = _interop_require_default._(require_router());
    var _routercontextsharedruntime = require_router_context_shared_runtime();
    var _iserror = _interop_require_default._(require_is_error());
    var _withrouter = _interop_require_default._(require_with_router());
    var singletonRouter2 = {
      router: null,
      readyCallbacks: [],
      ready(callback) {
        if (this.router) return callback();
        if (typeof window !== "undefined") {
          this.readyCallbacks.push(callback);
        }
      }
    };
    var urlPropertyFields = [
      "pathname",
      "route",
      "query",
      "asPath",
      "components",
      "isFallback",
      "basePath",
      "locale",
      "locales",
      "defaultLocale",
      "isReady",
      "isPreview",
      "isLocaleDomain",
      "domainLocales"
    ];
    var routerEvents = [
      "routeChangeStart",
      "beforeHistoryChange",
      "routeChangeComplete",
      "routeChangeError",
      "hashChangeStart",
      "hashChangeComplete"
    ];
    var coreMethodFields = [
      "push",
      "replace",
      "reload",
      "back",
      "prefetch",
      "beforePopState"
    ];
    Object.defineProperty(singletonRouter2, "events", {
      get() {
        return _router.default.events;
      }
    });
    function getRouter2() {
      if (!singletonRouter2.router) {
        const message = 'No router instance found.\nYou should only use "next/router" on the client side of your app.\n';
        throw Object.defineProperty(new Error(message), "__NEXT_ERROR_CODE", {
          value: "E394",
          enumerable: false,
          configurable: true
        });
      }
      return singletonRouter2.router;
    }
    urlPropertyFields.forEach((field) => {
      Object.defineProperty(singletonRouter2, field, {
        get() {
          const router = getRouter2();
          return router[field];
        }
      });
    });
    coreMethodFields.forEach((field) => {
      ;
      singletonRouter2[field] = function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        const router = getRouter2();
        return router[field](...args);
      };
    });
    routerEvents.forEach((event) => {
      singletonRouter2.ready(() => {
        _router.default.events.on(event, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          const eventField = "on" + event.charAt(0).toUpperCase() + event.substring(1);
          const _singletonRouter = singletonRouter2;
          if (_singletonRouter[eventField]) {
            try {
              _singletonRouter[eventField](...args);
            } catch (err) {
              console.error("Error when running the Router event: " + eventField);
              console.error((0, _iserror.default)(err) ? err.message + "\n" + err.stack : err + "");
            }
          }
        });
      });
    });
    var _default = singletonRouter2;
    function useRouter3() {
      const router = _react.default.useContext(_routercontextsharedruntime.RouterContext);
      if (!router) {
        throw Object.defineProperty(new Error("NextRouter was not mounted. https://nextjs.org/docs/messages/next-router-not-mounted"), "__NEXT_ERROR_CODE", {
          value: "E509",
          enumerable: false,
          configurable: true
        });
      }
      return router;
    }
    function createRouter2() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      singletonRouter2.router = new _router.default(...args);
      singletonRouter2.readyCallbacks.forEach((cb) => cb());
      singletonRouter2.readyCallbacks = [];
      return singletonRouter2.router;
    }
    function makePublicRouterInstance(router) {
      const scopedRouter = router;
      const instance = {};
      for (const property of urlPropertyFields) {
        if (typeof scopedRouter[property] === "object") {
          instance[property] = Object.assign(Array.isArray(scopedRouter[property]) ? [] : {}, scopedRouter[property]);
          continue;
        }
        instance[property] = scopedRouter[property];
      }
      instance.events = _router.default.events;
      coreMethodFields.forEach((field) => {
        instance[field] = function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return scopedRouter[field](...args);
        };
      });
      return instance;
    }
    if ((typeof exports.default === "function" || typeof exports.default === "object" && exports.default !== null) && typeof exports.default.__esModule === "undefined") {
      Object.defineProperty(exports.default, "__esModule", { value: true });
      Object.assign(exports.default, exports);
      module.exports = exports.default;
    }
  }
});

// portfolio-site/node_modules/vite-plugin-storybook-nextjs/dist/plugins/next-mocks/alias/router/index.js
var router_exports = {};
__export(router_exports, {
  createRouter: () => createRouter,
  default: () => router_default,
  getRouter: () => getRouter,
  useRouter: () => useRouter2,
  withRouter: () => withRouter2
});
var singletonRouter = __toESM(require_router2());
var import_router = __toESM(require_router2());
__reExport(router_exports, __toESM(require_router2()));
var defaultRouterState = {
  route: "/",
  asPath: "/",
  basePath: "/",
  pathname: "/",
  query: {},
  isFallback: false,
  isLocaleDomain: false,
  isReady: true,
  isPreview: false
};
var routerAPI;
var createRouter = (overrides) => {
  const routerActions = {
    push: fn2((..._args) => {
      return Promise.resolve(true);
    }).mockName("next/router::useRouter().push"),
    replace: fn2((..._args) => {
      return Promise.resolve(true);
    }).mockName("next/router::useRouter().replace"),
    reload: fn2((..._args) => {
    }).mockName(
      "next/router::useRouter().reload"
    ),
    back: fn2((..._args) => {
    }).mockName(
      "next/router::useRouter().back"
    ),
    forward: fn2(() => {
    }).mockName("next/router::useRouter().forward"),
    prefetch: fn2((..._args) => {
      return Promise.resolve();
    }).mockName("next/router::useRouter().prefetch"),
    beforePopState: fn2((..._args) => {
    }).mockName(
      "next/router::useRouter().beforePopState"
    )
  };
  const routerEvents = {
    on: fn2((..._args) => {
    }).mockName(
      "next/router::useRouter().events.on"
    ),
    off: fn2((..._args) => {
    }).mockName(
      "next/router::useRouter().events.off"
    ),
    emit: fn2((..._args) => {
    }).mockName(
      "next/router::useRouter().events.emit"
    )
  };
  if (overrides) {
    for (const key of Object.keys(routerActions)) {
      if (key in overrides) {
        routerActions[key] = fn2((...args) => {
          return overrides[key](...args);
        }).mockName(`useRouter().${key}`);
      }
    }
  }
  if (overrides?.events) {
    for (const key of Object.keys(routerEvents)) {
      if (key in routerEvents) {
        routerEvents[key] = fn2((...args) => {
          return overrides.events[key](...args);
        }).mockName(`useRouter().events.${key}`);
      }
    }
  }
  routerAPI = {
    ...defaultRouterState,
    ...overrides,
    ...routerActions,
    // @ts-expect-error TODO improve typings
    events: routerEvents
  };
  import_router.default.router = routerAPI;
  for (const cb of import_router.default.readyCallbacks) {
    cb();
  }
  import_router.default.readyCallbacks = [];
  return routerAPI;
};
var getRouter = () => {
  if (!routerAPI) {
    throw new NextjsRouterMocksNotAvailable({
      importType: "next/router"
    });
  }
  return routerAPI;
};
var router_default = import_router.default;
var useRouter2 = fn2(
  singletonRouter.useRouter
).mockName("next/router::useRouter");
var withRouter2 = fn2(singletonRouter.withRouter).mockName("next/router::withRouter");
export {
  createRouter,
  router_default as default,
  getRouter,
  useRouter2 as useRouter,
  withRouter2 as withRouter
};
//# sourceMappingURL=@storybook_nextjs-vite_router__mock.js.map
